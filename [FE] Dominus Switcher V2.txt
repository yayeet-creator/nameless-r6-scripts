local Player = game:GetService("Players").LocalPlayer   --<=== Replace With Your Name


local Mouse = Player:GetMouse()

---------Replace All "LocalPlayer" With Your Name.
--Remove "Mouse =" or "local mouse =" at the start.
--Replace Kermat161 At The Top Of The Script With You Name.
-----------------------------Script In The Line's.




--//====================================================\\--
--||               CREATED BY SHACKLUSTER
--\\====================================================//--

 
 
 
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Player:ClearCharacterAppearance()
local sick = Instance.new("Sound",Character)
sick.SoundId = "rbxassetid://195900687"
sick.Looped = true
sick.Pitch = 1
sick.Volume = 3
sick:Play()
local firesound = Instance.new("Sound",RootPart)
firesound.SoundId = "rbxassetid://987328482"
firesound.Looped = true
firesound.Pitch = 1
firesound.Volume = 0
firesound:Play()


IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
 
function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
    local NEWMESH = IT(MESH)
    if MESH == "SpecialMesh" then
        NEWMESH.MeshType = MESHTYPE
        if MESHID ~= "nil" and MESHID ~= "" then
            NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
        end
        if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
            NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
        end
    end
    NEWMESH.Offset = OFFSET or VT(0, 0, 0)
    NEWMESH.Scale = SCALE
    NEWMESH.Parent = PARENT
    return NEWMESH
end
 
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
    local NEWPART = IT("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = Torso.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end
 
--//=================================\\
--||          CUSTOMIZATION
--\\=================================//
 
Player_Size = 1 --Size of the player.
Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local MODE = "Main"
local SIZE = 1
local LEVEL = 1


local Speed = 16
local Effects2 = {}
 
--//=================================\\
--||      END OF CUSTOMIZATION
--\\=================================//
 
    local function weldBetween(a, b)
        local weldd = Instance.new("ManualWeld")
        weldd.Part0 = a
        weldd.Part1 = b
        weldd.C0 = CFrame.new()
        weldd.C1 = b.CFrame:inverse() * a.CFrame
        weldd.Parent = a
        return weldd
    end
 
--//=================================\\
--||          USEFUL VALUES
--\\=================================//
 
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local CHANGEDEFENSE = 0
local CHANGEDAMAGE = 0
local CHANGEMOVEMENT = 0
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local VOCALS_ENRAGES = {528589078,528589175,528589274,528589382}
local WALKINGANIM = false
local WALK = 0
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
sick.Volume = 0
Character.Archivable = true
local CLONE = Character:Clone()
CLONE.Parent = nil
Character.Archivable = false
sick.Volume = 3
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}
local HITARMORSOUNDS = {"199149321", "199149338", "199149367", "199149409", "199149452"}
local HITWEAPONSOUNDS = {"199148971", "199149025", "199149072", "199149109", "199149119"}
local HITBLOCKSOUNDS = {"199148933", "199148947"}
local UNANCHOR = true
local BodyColor = C3(0,0,0)
local LegColor = C3(0,0,0.05)
local ArmColor = C3(0.05,0.05,0.15)

local SKILLTEXTCOLOR = C3(0.05,0.05,0.15)
local SKILLTEXTCOLOR2 = C3(0,0,0)

--//=================================\\
--\\=================================//
 
 
--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//
 
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
 
script:WaitForChild("ArtificialHB")
 
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
 
game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.ArtificialHB:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.ArtificialHB:Fire()
            end
        lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)
 
--//=================================\\
--\\=================================//
 
 
 
 
 
--//=================================\\
--||          SOME FUNCTIONS
--\\=================================//
 
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
    return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
 
function PositiveAngle(NUMBER)
    if NUMBER >= 0 then
        NUMBER = 0
    end
    return NUMBER
end
 
function NegativeAngle(NUMBER)
    if NUMBER <= 0 then
        NUMBER = 0
    end
    return NUMBER
end
 
function Swait(NUMBER)
    if NUMBER == 0 or NUMBER == nil then
        ArtificialHB.Event:wait()
    else
        for i = 1, NUMBER do
            ArtificialHB.Event:wait()
        end
    end
end
 
function QuaternionFromCFrame(cf)
    local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
    local trace = m00 + m11 + m22
    if trace > 0 then
        local s = math.sqrt(1 + trace)
        local recip = 0.5 / s
        return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
    else
        local i = 0
        if m11 > m00 then
            i = 1
        end
        if m22 > (i == 0 and m00 or m11) then
            i = 2
        end
        if i == 0 then
            local s = math.sqrt(m00 - m11 - m22 + 1)
            local recip = 0.5 / s
            return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
        elseif i == 1 then
            local s = math.sqrt(m11 - m22 - m00 + 1)
            local recip = 0.5 / s
            return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
        elseif i == 2 then
            local s = math.sqrt(m22 - m00 - m11 + 1)
            local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
        end
    end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
    local xs, ys, zs = x + x, y + y, z + z
    local wx, wy, wz = w * xs, w * ys, w * zs
    local xx = x * xs
    local xy = x * ys
    local xz = x * zs
    local yy = y * ys
    local yz = y * zs
    local zz = z * zs
    return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
    local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
    local startInterp, finishInterp;
    if cosTheta >= 0.0001 then
        if (1 - cosTheta) > 0.0001 then
            local theta = ACOS(cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((1 - t) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = 1 - t
            finishInterp = t
        end
    else
        if (1 + cosTheta) > 0.0001 then
            local theta = ACOS(-cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((t - 1) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
    end
    return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
 
function Clerp(a, b, t)
    local qa = {QuaternionFromCFrame(a)}
    local qb = {QuaternionFromCFrame(b)}
    local ax, ay, az = a.x, a.y, a.z
    local bx, by, bz = b.x, b.y, b.z
    local _t = 1 - t
    return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
 
function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
    local frame = IT("Frame")
    frame.BackgroundTransparency = TRANSPARENCY
    frame.BorderSizePixel = BORDERSIZEPIXEL
    frame.Position = POSITION
    frame.Size = SIZE
    frame.BackgroundColor3 = COLOR
    frame.BorderColor3 = BORDERCOLOR
    frame.Name = NAME
    frame.Parent = PARENT
    return frame
end
 
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
    local label = IT("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UD2(1, 0, 1, 0)
    label.Position = UD2(0, 0, 0, 0)
    label.TextColor3 = TEXTCOLOR
    label.TextStrokeTransparency = STROKETRANSPARENCY
    label.TextTransparency = TRANSPARENCY
    label.FontSize = TEXTFONTSIZE
    label.Font = TEXTFONT
    label.BorderSizePixel = BORDERSIZEPIXEL
    label.TextScaled = false
    label.Text = TEXT
    label.Name = NAME
    label.Parent = PARENT
    return label
end
 
function NoOutlines(PART)
    PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end
 
 
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
    local NEWWELD = IT(TYPE)
    NEWWELD.Part0 = PART0
    NEWWELD.Part1 = PART1
    NEWWELD.C0 = C0
    NEWWELD.C1 = C1
    NEWWELD.Parent = PARENT
    return NEWWELD
end
 
function CreateSound(ID, PARENT, VOLUME, PITCH)
    local NEWSOUND = nil
    coroutine.resume(coroutine.create(function()
        NEWSOUND = IT("Sound", PARENT)
        NEWSOUND.Volume = VOLUME
        NEWSOUND.Pitch = PITCH
        NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
        Swait()
        NEWSOUND:play()
        game:GetService("Debris"):AddItem(NEWSOUND, 10)
    end))
    return NEWSOUND
end
 
function CFrameFromTopBack(at, top, back)
    local right = top:Cross(back)
    return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
 
function CreateSwirl(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
    wave.Color = COLOR
    local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
            if DOESROT == true then
                wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
            end
            wave.Transparency = wave.Transparency + (0.5/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
    wave.Color = COLOR
    local mesh = CreateMesh("SpecialMesh", wave, "Sphere", "", "", SIZE, VT(0,0,0))
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            wave.Transparency = wave.Transparency + (1/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function Slice(KIND,SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(1,1,1), true)
    local mesh = nil
    if KIND == "Base" then
        mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
    elseif KIND == "Thin" then
        mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
    elseif KIND == "Round" then
        mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
    end
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW/10
            wave.Transparency = wave.Transparency + (0.5/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end
 
function MakeForm(PART,TYPE)
    if TYPE == "Cyl" then
        local MSH = IT("CylinderMesh",PART)
    elseif TYPE == "Ball" then
        local MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Sphere"
    elseif TYPE == "Wedge" then
        local MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Wedge"
    end
end
 
function CheckTableForString(Table, String)
    for i, v in pairs(Table) do
        if string.find(string.lower(String), string.lower(v)) then
            return true
        end
    end
    return false
end
 
Debris = game:GetService("Debris")
 
function FireArc(Part,ToLocation,AmountOfTime,Height,DoesCourontine)
    if DoesCourontine == false then
        local Direction = CF(Part.Position,ToLocation)
        local Distance = (Part.Position - ToLocation).magnitude
        for i = 1, AmountOfTime do
            Swait()
            Part.CFrame = Direction*CF(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
            Direction = Part.CFrame
        end
        Part:remove()
    elseif DoesCourontine == true then
        coroutine.resume(coroutine.create(function()
            local Direction = CF(Part.Position,ToLocation)
            local Distance = (Part.Position - ToLocation).magnitude
            for i = 1, AmountOfTime do
                Swait()
                Part.CFrame = Direction*CF(0,(AmountOfTime/200)+((AmountOfTime/Height)-((i*2)/Height)),-Distance/AmountOfTime)
                Direction = Part.CFrame
            end
            Part:remove()
        end))
    end
end
 
function turnto(position)
    RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end
local naeeym2 = Instance.new("BillboardGui", Character)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5, 35, 2, 15)
naeeym2.StudsOffset = Vector3.new(0, 3, 0)
naeeym2.Adornee = Character.Head
naeeym2.Name = "Name"
local tecks2 = Instance.new("TextLabel", naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Dominus Astra"
tecks2.Font = "Fantasy"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0.05,0.05,0.15)
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1, 0, 0.5, 0)
tecks2.Parent = naeeym2

--//=================================\\
--||         WEAPON CREATION
--\\=================================//
 
local LMAO = IT("Model")
LMAO.Name = "Particles"
LMAO.Parent = nil
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Weapon2 = IT("Model")
Weapon2.Name = "Adds"

Weapon2.Parent = nil

local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.3,0.95),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 1
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(0.4,0,0),C3(0.4,0,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

local Handle = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.6,0.2),false)
local RightArmGrasp = CreateWeldOrSnapOrMotor("Weld", Handle, RightArm, Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.3, 0.2) * ANGLES(RAD(0), RAD(180), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.3,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.4, 0) * ANGLES(RAD(0), RAD(0), RAD(180)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.3,0.3),false)
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.5, 0.2) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.5,0.5),false)
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.4,0.4,0.4),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
for i = 1, 8 do
	local Piece = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Eye", VT(0,0.35,0.41),false)
	CreateWeldOrSnapOrMotor("Weld", Handle, Part, Piece, CF(0, 0, 0) * ANGLES(RAD(0), RAD((360/8)*i), RAD(0)), CF(0, 0, 0))
end
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Eye", VT(0.38,0.41,0.38),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.37,0.5,0.37),false)
MakeForm(Part,"Ball")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.3) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.7,0.4),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.7, 0.5) * ANGLES(RAD(90), RAD(180), RAD(180)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.3,0.4,0.2),false)
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.35,0.35,0.35),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.5),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.5,0.1,0.45),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 1.1) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.2,0.5,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.55, 0.2) * ANGLES(RAD(-135), RAD(0), RAD(0)), CF(0, -0.3, 0))
local LASTPART = Handle
for i = 1, 10 do
	if LASTPART == Handle then
		local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.2,0),false)
		LASTPART = Part
		CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.1, 0.2) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
	else
		local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.1,0.05,0),false)
		CreateWeldOrSnapOrMotor("Weld", Handle, LASTPART, Part, CF(0, 0.025, 0) * ANGLES(RAD(8), RAD(0), RAD(0)), CF(0, -0.025, 0))
		LASTPART = Part
	end
end

local Barrel = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.15,2,0.15),false)
MakeForm(Barrel,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Barrel, CF(0, -0.6, 1.8) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0.25,1,0.25),false)
MakeForm(Part,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, -0.6, 0), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0,0.1,0.2),false)
MakeForm(Part,"Wedge")
CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Part, CF(0, 0.945, 0.1) * ANGLES(RAD(180), RAD(0), RAD(0)), CF(0, 0, 0))
local Hole2 = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Eye", VT(0.125,0,0.125),false)
MakeForm(Hole2,"Cyl")
CreateWeldOrSnapOrMotor("Weld", Handle, Barrel, Hole2, CF(0, 0.98, 0), CF(0, 0, 0))
local Part = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Part", VT(0,0,0),false)
local GEARWELD = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.8,0.8,1.5), VT(0,0,0.2))
local Part = CreatePart(3, Weapon, "Metal", 0, 0.5, "Mid gray", "Eye", VT(0,0,0),false)
local GEARWELD2 = CreateWeldOrSnapOrMotor("Weld", Handle, Handle, Part, CF(0, -0.6, 0.7), CF(0, 0, 0))
CreateMesh("SpecialMesh", Part, "FileMesh", 156292343, "", VT(0.9,0.9,0.3), VT(0,0,0.2))
coroutine.resume(coroutine.create(function()
	while wait() do
		GEARWELD.C0 = GEARWELD.C0 * ANGLES(RAD(0), RAD(0), RAD(5))
		GEARWELD2.C0 = GEARWELD2.C0 * ANGLES(RAD(0), RAD(0), RAD(-5))
	end
end))

ParticleEmitter({Speed = 0.2, Drag = 0, Size1 = 0.1, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.5, Parent = Hole2, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})
--ParticleEmitter({Speed = 0.5, Drag = 0, Size1 = 0.2, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.7, Parent = Dangle, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})

ParticleEmitter({Speed = 0.2, Drag = 0, Size1 = 0.1, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.5, Parent = Hole2, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})
--ParticleEmitter({Speed = 0.5, Drag = 0, Size1 = 0.2, Size2 = 0, Lifetime1 = 0.3, Lifetime2 = 0.7, Parent = Dangle, Emit = 100, Offset = 360, Enabled = true, Acel = VT(0,5,0)})

for _, c in pairs(Weapon:GetDescendants()) do
	if c.ClassName == "Part" and c.Name ~= "Eye" and c.Parent ~= Effects and c.Parent.Parent ~= Effects then
		c.Material = "Glass"
		c.Color = C3(0.15,0.05,0.05)
	elseif c.ClassName == "Part" and c.Name == "Eye" then
		c.Color = C3(1,0,0)
		c.Material = "Neon"
	end
end

for _, c in pairs(Weapon:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

function Transparency(TRANS)
    for _, c in pairs(Character:GetChildren()) do
        if c.ClassName == "Part" and c ~= RootPart then
            c.Transparency = TRANS
            if c:FindFirstChildOfClass("Decal") then
                c:FindFirstChildOfClass("Decal").Transparency = TRANS
            end
        elseif c.ClassName == "Accessory" then
            c.Handle.Transparency = TRANS
        elseif c.ClassName == "Model" then
            for _, q in pairs(c:GetChildren()) do
                if q.ClassName == "Part" then
                    q.Transparency = TRANS
                    if q:FindFirstChildOfClass("Decal") then
                        q:FindFirstChildOfClass("Decal").Transparency = TRANS
                    end
                end
            end
        end
    end
end

 
--//=================================\\
--||            DAMAGING
--\\=================================//
 
function killnearest(position,range,maxstrength)
    for i,v in ipairs(workspace:GetChildren()) do
    local body = v:GetChildren()
        for part = 1, #body do
            if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
                if(body[part].Position - position).Magnitude < range then
                    if v.ClassName == "Model" then
                        v:BreakJoints()
                    end
                    --table.insert(Effects2,{body[part],"Disappear",0.02,2,2,2,2})
                    local bv = Instance.new("BodyVelocity")
                    bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
                    bv.velocity = CF(position,body[part].Position).lookVector*maxstrength
                    bv.Parent = body[part]
                    Debris:AddItem(bv,0.2)
                end
            end
        end
        if v.ClassName == "Part" then
            if v.Anchored == false and (v.Position - position).Magnitude < range then
                --table.insert(Effects2,{v,"Disappear",0.02,2,2,2,2})
                v.Velocity = CFrame.new(position,v.Position).lookVector*5*maxstrength
            end
        end
    end
end
 
--//=================================\\
--||    ATTACK FUNCTIONS AND STUFF
--\\=================================//

local TOBANISH = {}

function printbye(Name)
	local MESSAGES = {"Tu, ne ipsis, ","Esses contumeliam, ","Te potest ignorare mandatum meum, ","Iam mortuus est, "}
	warn(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end
	
workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			--if game.Players:FindFirstChild(Foe.Name) then
				table.insert(TOBANISH,Foe.Name)
				printbye(Foe.Name)
			--end
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
 						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,0,0)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "Really red", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(5,DIST,5)
	else
		TRAIL.Size = VT(5,DIST,5)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

local Decal = IT("Decal")
function MagicRing()
	local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	local decal = Decal:Clone()
	decal.Parent = O1
	decal.Face = "Top"
	decal.Texture = "http://www.roblox.com/asset/?id=917750924"
	local decal2 = Decal:Clone()
	decal2.Parent = O1
	decal2.Face = "Bottom"
	decal2.Texture = "http://www.roblox.com/asset/?id=917750924"
	return O1
end

local EyeSizes = {
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
}
local PE = Instance.new("ParticleEmitter")
PE.LightEmission = 0.8
PE.Color = ColorSequence.new(BRICKC("Gold").Color)
PE.Size = NumberSequence.new(EyeSizes)
PE.Lifetime = NumberRange.new(0.35, 0.35, 0.35)
PE.Rotation = NumberRange.new(0, 360)
PE.Transparency = NumberSequence.new(0.9)
PE.Rate = 999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0, 75, 0)
PE.Drag = 5
PE.Speed = NumberRange.new(6, 6)
PE.Texture = "http://www.roblox.com/asset/?id=1351966707"
PE.ZOffset = -1.5
PE.Name = "OVERLORDAURA"

function particles(art)
	PE:Clone().Parent = art
end

function CheckIntangible(Hit)
	local ProjectileNames = {
		"Water",
		"Arrow",
		"Projectile",
		"Effect",
		"Rail",
		"Lightning",
		"Bullet"
	}
	if Hit and Hit.Parent and (not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid") then
		return true
	end
	return false
end
Debris = game:GetService("Debris")
function CastZapRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Ignore = type(Ignore) == "table" and Ignore or {Ignore}
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastZapRay(RayPos + Vec * 0.01, Vec, Length - (StartPos - RayPos).magnitude, Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end
BaseLightning = IT("Part")
BaseLightning.Anchored = true
BaseLightning.CanCollide = false
BaseLightning.Material = "Neon"
local LightningBolts = {}
function Zap(Table)
	local StartPos, TargetPos, Character, Color = Table.StartPosition, Table.TargetPosition, Table.Character, Table.Color
	local Duration = Table.Duration or 2
	local Offset = Table.Offset or 2
	local Individualize = Table.Individualize or false
	local MaxRange = Table.MaxRange or 200
	local SegmentLength = Table.SegmentLength or 5
	local Transparency = Table.Transparency or 0
	local Ignore = Table.Ignore or {}
	local SIZE = Table.SIZE or 0.3
	if not (StartPos and TargetPos) or not Character then
		return
	end
	local LightningModel = IT("Folder", Effects)
	LightningModel.Name = "ZAPP"
	for i, v in pairs({Character, LightningModel}) do
		table.insert(Ignore, v)
	end
	local LastPos = StartPos
	local Direction = CFrame.new(StartPos, TargetPos).lookVector
	local RayHit, RayPos, RayNormal = CastZapRay(StartPos, Direction, MaxRange, Ignore, false)
	local RayLength = (StartPos - RayPos).Magnitude
	local Struck = false
	local TotalSegments = math.ceil(RayLength / SegmentLength)
	Direction = CFrame.new(StartPos, RayPos).lookVector
	local LightningBolt = IT("Model", Effects)
	LightningBolt.Name = "Lightning"
	if not Individualize then
		table.insert(LightningBolts, LightningBolt)
	end
	LastBolt = LightningBolt
	Debris:AddItem(LightningBolt, Duration)
	LightningBolt.Parent = LightningModel
	for i = 1, TotalSegments do
		if not Struck then
			local Entropy = Vector3.new(math.random() * Offset * 2.5 - Offset, math.random() * Offset * 2.5 - Offset, math.random() * Offset * 2.5 - Offset)
			local NewPos = StartPos + Direction * (RayLength * (i / TotalSegments)) + Entropy
			local SegmentVec = NewPos - LastPos
			local RayHit, RayPos, RayNormal = CastZapRay(LastPos, SegmentVec.Unit, SegmentVec.Magnitude, {Character, LightningModel}, false)
			local RayVec = LastPos - RayPos
			local LightningPart = BaseLightning:Clone()
			LightningPart.BrickColor = BrickColor.new(Color)
			LightningPart.Transparency = Transparency
			LightningPart.Size = Vector3.new(SIZE, SIZE, RayVec.Magnitude)
			LightningPart.CFrame = CFrame.new(LastPos, RayPos) * CFrame.new(0, 0, -(RayVec.Magnitude / 2))
			table.insert(Effects2, {
				LightningPart,
				"Disappear",
				0.025,
				1,
				1,
				1,
				2
			})
			local CylinderMesh = IT("CylinderMesh", LightningPart)
			local OrigCF = LightningPart.CFrame
			LightningPart.Size = Vector3.new(LightningPart.Size.X, LightningPart.Size.Z, LightningPart.Size.Y)
			LightningPart.CFrame = OrigCF * CFrame.Angles(math.pi / 2, 0, 0)
			LightningPart.Parent = LightningBolt
			LastPos = NewPos
		end
	end
	return {
		RayHit = RayHit,
		RayPos = RayPos,
		RayNormal = RayNormal,
		LightningModel = LightningModel
	}
end

function CreateWave(SIZE, WAIT, CFRAME, DOESROT, ROT, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0, 0, -(mesh.Scale.X / 8))
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function AddChildrenToTable(FROM, PARENT, DIST, TABLE)
	for _, c in pairs(PARENT:GetChildren()) do
		if c.ClassName == "Model" then
			if c ~= Character and c:FindFirstChildOfClass("Humanoid") and (c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) then
				local HUMANOID = c:FindFirstChildOfClass("Humanoid")
				local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
				if DIST > (TORSO.Position - FROM).Magnitude then
					table.insert(TABLE, c)
				end
				AddChildrenToTable(FROM, c, DIST, TABLE)
			elseif c.ClassName == "Folder" then
				AddChildrenToTable(FROM, c, DIST, TABLE)
			end
		end
	end
end

local ATTACKTAUNTS = {
	"907329893",
	"907329532",
	"907333294",
	"907332856"
}
local ULTTAUNTS = {
	"907332997",
	"907332670",
	"907330103"
}

function Lunar_Blast()
    local HITBODIES = {}
    local CENTER = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Relly red", "CenterPart", VT(0,0,0))
    local HITFLOOR,ECH,NORMAL = Raycast(Mouse.Hit.p+VT(0,2,0), (CF(Mouse.Hit.p, Mouse.Hit.p + VT(0, -1, 0))).lookVector, 10000000, Character)
    CENTER.CFrame = CF(ECH)
    local RAY = CreatePart(3, Effects, "Neon", 0, 1, "Relly red", "Laser01", VT(25,99999,25))
    RAY.Color = C3(0.05,0.05,0.15)
    MakeForm(RAY,"Cyl")
    RAY.CFrame = CF(ECH)
    for i = 1, 75 do
        Swait()
        RAY.Transparency = RAY.Transparency - 1/75
        RAY.Size = RAY.Size - VT(25/75,0,25/75)
        MagicSphere(VT(1,1,1),15,CF(ECH)*CF(MRANDOM(-15,15),MRANDOM(0,100),MRANDOM(-15,15)),C3(1,1,1),VT(0,0,0))
    end
    killnearest(ECH,25,25)
    MagicSphere(VT(0,0,0),55,CF(ECH),C3(0.05,0.05,0.15),VT(2,2,2))
    for i = 1, 25 do
        MagicSphere(VT(1,1,1),i*3,CF(ECH)*CF(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45)),C3(1,1,1),VT(0,0,0))
    end
    CreateSound("168586621", CENTER, 10, 0.8)
    RAY:remove()
    Debris:AddItem(CENTER,5)
end
 
function Star_Cutter()
    local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
    if HITFLOOR ~= nil then
        ATTACK = true
        Rooted = true
        local GYRO = IT("BodyGyro",RootPart)
        GYRO.D = 100
        GYRO.P = 2000
        GYRO.MaxTorque = VT(0,4000000,0)
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
        CreateSound("429459101", RightArm, 10, 0.8)
        for i=0, 3.5, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            Slice("Thin",0.3,5,RightArm.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),"Really red",VT(-0.01,0,-0.01))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(-15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        GYRO:remove()
        for i=0, 0.15, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            Slice("Thin",0.3,5,RightArm.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),"Really red",VT(-0.01,0,-0.01))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        local BOMBSPOTS = {}
        for i = 1, 25 do
            local SPOT = CreatePart(3, Effects, "Neon", 0, 0, "Relly blue", "Blade", VT(8,1,8))
            SPOT.Color = SKILLTEXTCOLOR
            SPOT.CFrame = RootPart.CFrame*CF((MRANDOM(-15,15)/40)*i,-5,-i*5)
            table.insert(BOMBSPOTS,SPOT)
            MakeForm(SPOT,"Cyl")
        end
        for i=0, 0.2, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(145), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        ATTACK = false
        Rooted = false
        coroutine.resume(coroutine.create(function()
            Swait(3)
            for i = 1, #BOMBSPOTS do
                if BOMBSPOTS[i] ~= nil then
                    local E = BOMBSPOTS[i]
                    coroutine.resume(coroutine.create(function()
                        local BLADE = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Relly blue", "Blade", VT(0,0,0))
                        BLADE.Color = SKILLTEXTCOLOR
                        CreateMesh("SpecialMesh", BLADE, "FileMesh", "93108071", "", VT(0.6,1,0.4)*3, VT(0,0,0))
                        CreateSound(HITWEAPONSOUNDS[MRANDOM(1,#HITWEAPONSOUNDS)], BLADE, 4, 0.6)
                        BLADE.CFrame = E.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-15,15)),RAD(90),RAD(MRANDOM(-15,15)))
                        for i = 1, 10 do
                            Swait()
                            MagicSphere(VT(1,1,1)/5,65,CF(E.Position)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))*CF(0,MRANDOM(3,6),0),C3(1,1,1),VT(0,0,0))
                            killnearest(BLADE.Position,6,80)
                            BLADE.CFrame = BLADE.CFrame*CF(0,0.3,0)
                            BLADE.Transparency = BLADE.Transparency - 0.1
                        end
                        Swait(45)
                        for i = 1, 100 do
                            Swait()
                            BLADE.Transparency = BLADE.Transparency + 0.01
                            E.Transparency = E.Transparency + 0.01
                        end
                        BLADE:remove()
                        E:remove()
                    end))
                end
            end
        end))
    end
end
 
function Supernova()
    local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
    if HITFLOOR ~= nil then
        local HITBODIES = {}
        ATTACK = true
        Rooted = true
        local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "Relly red", "Star", VT(0,0,0))
        MakeForm(ABSOLUTE,"Ball")
        CreateSound("429459101", ABSOLUTE, 10, 1)
        for i=0, 4, 0.1 / Animation_Speed do
            Swait()
            ABSOLUTE.Size = ABSOLUTE.Size + VT(0.2,0.2,0.2)
            ABSOLUTE.CFrame = RootPart.CFrame*CF(0,5+(ABSOLUTE.Size.Y/2),0)
            ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
            local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Star", VT(1,1,1))
            MakeForm(CHARGE,"Ball")
            CHARGE.Color = C3(1,1,1)
            CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15,15),-6,MRANDOM(-15,15))
            FireArc(CHARGE,ABSOLUTE.Position,45,45,true)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        CreateSound("907330103", Head, 10, 1.2)
        for i = 1, 75 do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        coroutine.resume(coroutine.create(function()
            for i = 1, 13 do
                for e = 1, 8 do
                    Swait()
                    MagicSphere(VT(1,1,1),15,CF(ABSOLUTE.Position)*CF(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45)),C3(1,1,1),VT(0,0,0))
                    CreateSwirl(ABSOLUTE.Size/2,15,CF(HITPOS),true,15,BRICKC"Slime green".Color,VT(i,0.3,i)*2)
                end
                for i = 1, 5 do
                    Slice("Round",0,35,CF(ABSOLUTE.Position)*ANGLES(RAD(MRANDOM(-18,18)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-18,18))),C3(1,1,1),VT(i,0,i)/3)
                    Slice("Thin",i,55,ABSOLUTE.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),C3(1,0,0),VT(0,0,0))
                end
                CreateSwirl(ABSOLUTE.Size/2,25,CF(ABSOLUTE.Position),true,-25,BRICKC"Relly red".Color,VT(i,i*2,i))
                CreateSwirl(ABSOLUTE.Size/2,55,CF(ABSOLUTE.Position),true,25,C3(0.05,0.05,0.15),VT(i,i*2,i))
                CreateSound("168586621", ABSOLUTE, 4, 0.8)
                CreateSound("201858144", ABSOLUTE, 10, 0.8)
                killnearest(ABSOLUTE.Position,i*18,i)
                ABSOLUTE.Size = ABSOLUTE.Size*0.9
                MagicSphere(ABSOLUTE.Size,25,CF(ABSOLUTE.Position),BRICKC"Relly red".Color,VT(i,i,i)/1.1)
                MagicSphere(ABSOLUTE.Size,45,CF(ABSOLUTE.Position),C3(0.05,0.05,0.15),VT(i,i,i))
            end
            ABSOLUTE.Transparency = 1
            Debris:AddItem(ABSOLUTE,10)
        end))
        ATTACK = false
        Rooted = false
    end
end
 
local Decal = IT("Decal")
 
function Astral_Hop()
    ATTACK = true
    Rooted = false
    local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0,0,0))
    O1.CFrame = RootPart.CFrame*CF(0,0,-3)*ANGLES(RAD(90),RAD(0),RAD(0))
    local decal = Decal:Clone()
    decal.Parent = O1
    decal.Face = "Top"
    decal.Texture = "http://www.roblox.com/asset/?id=349165228"
    local decal2 = Decal:Clone()
    decal2.Parent = O1
    decal2.Face = "Bottom"
    decal2.Texture = "http://www.roblox.com/asset/?id=349165228"
    local O2 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0,0,0))
    local POS = VT(RootPart.Position.X,Mouse.Hit.p.Y+6,RootPart.Position.Z)
    O2.CFrame = CF(Mouse.Hit.p+VT(0,6,0),POS)*ANGLES(RAD(90),RAD(0),RAD(0))
    local ROOT = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0,0,0))
    ROOT.CFrame = CF(O2.Position,RootPart.Position)
    local decal = Decal:Clone()
    decal.Parent = O2
    decal.Face = "Top"
    decal.Texture = "http://www.roblox.com/asset/?id=349165228"
    local decal2 = Decal:Clone()
    decal2.Parent = O2
    decal2.Face = "Bottom"
    decal2.Texture = "http://www.roblox.com/asset/?id=349165228"
    CreateSound("84005018", O1, 10, 0.7)
    CreateSound("84005018", O2, 10, 0.7)
    for i = 1, 75 do
        Swait()
        O1.Size = O1.Size + VT(0.1,0,0.1)
        O1.CFrame = RootPart.CFrame*CF(0,0,-3)*ANGLES(RAD(90),RAD(i),RAD(0))
        O2.Size = O2.Size + VT(0.1,0,0.1)
        O2.CFrame = O2.CFrame*ANGLES(RAD(0),RAD(i),RAD(0))
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(90), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(90), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
    end
    Rooted = true
    UNANCHOR = false
    RootPart.Anchored = true
    VALUE1 = true
    for i = 1, 15 do
        Transparency(i/15)
        Swait()
        RootPart.CFrame = RootPart.CFrame*CF(0,0,-0.13)
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
    end
    RootPart.CFrame = ROOT.CFrame
    ROOT:remove()
    for i = 1, 15 do
        Transparency(1-(i/15))
        Swait()
        RootPart.CFrame = RootPart.CFrame*CF(0,0,-0.5)
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
    end
    VALUE1 = false
    coroutine.resume(coroutine.create(function()
        for i = 1, 75 do
            Swait()
            O1.Size = O1.Size - VT(0.1,0,0.1)
            O1.CFrame = O1.CFrame*ANGLES(RAD(0),RAD(i),RAD(0))
            O2.Size = O2.Size - VT(0.1,0,0.1)
            O2.CFrame = O2.CFrame*ANGLES(RAD(0),RAD(i),RAD(0))
        end
        O1:remove()
        O2:remove()
    end))
    UNANCHOR = true
    RootPart.Anchored = false
    ATTACK = false
    Rooted = false
end

function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat wait(1) until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function PhForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Main" then
		sick.SoundId = "rbxassetid://1418800825"
		sick.Volume = 6
		sick.Pitch = 1
		sick.TimePosition = 1
		-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		for i=0, 1.5, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(80), RAD(75), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Phaedra"
		SKILLTEXTCOLOR = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
		SKILLTEXTCOLOR2 = C3(1,1,1)
		firesound.Volume = 6
		Weapon2.Parent = Character
		for i=0, 1.5, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)

			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 20
		tecks2.Text = "Dominus Phaedra"
	elseif MODE == "Phaedra" then
		firesound.Volume = 0
		Weapon2.Parent = nil
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
		WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function UpForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Phaedra" then
		
		sick.SoundId = "rbxassetid://700037500"
		sick.Volume = 10
		sick.Pitch = 1
		sick.TimePosition = 1
	-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		for i=0, 1.5, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(80), RAD(75), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Ultra Phaedra"
		Humanoid.HipHeight = 4
		SKILLTEXTCOLOR = C3(0.8, 0.6, 0.4)
		SKILLTEXTCOLOR2 = C3(1,1,1)
		firesound.Volume = 10
		firesound.Parent = Character
		Weapon2.Parent = Character
		for i=0, 1.5, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)

			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Speed = 20
		tecks2.Text = "Ultima Dominus Phaedra"
	elseif MODE == "Ultra Phaedra" then
		firesound.Volume = 0
		firesound.Parent = RootPart
		Humanoid.HipHeight = 2
		Weapon2.Parent = nil
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
		WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function TeForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Main" then
		sick.SoundId = "rbxassetid://926658175"
		sick.Volume = 3
		sick.Pitch = 1
		sick.TimePosition = 1
		SKILLTEXTCOLOR = C3(0.05,0.05,0.05)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		CreateSound(363808674, Torso, 6, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)

			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Tenebris"
		tecks2.Text = "Dominus Tenebris"
		SKILLTEXTCOLOR = C3(0.05,0,0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		Speed = 20
	elseif MODE == "Tenebris" then
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
    WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function VeForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Tenebris" then
		sick.SoundId = "rbxassetid://968448494"
		sick.Volume = 4
		sick.Pitch = 1.15
		sick.TimePosition = 1
		SKILLTEXTCOLOR = C3(0.05,0.05,0.05)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)

			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Venari"
		tecks2.Text = "Dominus Venari"
		SKILLTEXTCOLOR = C3(5,5,0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		Speed = 20
	elseif MODE == "Venari" then
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
		WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function InForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Main" then
		sick.SoundId = "rbxassetid://415891745"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 1
		SKILLTEXTCOLOR = C3(0.05,0.05,0.05)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		-- Animation --
	SKILLTEXTCOLOR = BrickColor.random().Color
	SKILLTEXTCOLOR2 = BrickColor.random().Color
		MODE = "Insaniam"
		tecks2.Text = "Dominus Insaniam"
		SKILLTEXTCOLOR = C3(5,5,0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		Speed = 14
	elseif MODE == "Insaniam" then
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
    WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function PrForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Main" then
		sick.SoundId = "rbxassetid://859912308"
		sick.Volume = 3
		sick.Pitch = 1
		sick.TimePosition = 1
	SKILLTEXTCOLOR = C3(0, 0.03, 0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		CreateSound(363808674, Torso, 6, 1, false)
		MODE = "Praefectus"
		tecks2.Text = "Dominus Praefectus"
		Speed = 20
	elseif MODE == "Praefectus" then
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
    WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function BaForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Main" then
		sick.SoundId = "rbxassetid://1392856912"
		sick.Volume = 10
		sick.Pitch = 0.97
		sick.TimePosition = 1
	coroutine.resume(coroutine.create(function()
		end))
		for i=0, 2, 0.1 / Animation_Speed do
			Swait()
			CreateRing(VT(0,0,0.1),false,0,15,CF(HITPOS)*ANGLES(RAD(90),RAD(0),RAD(0)),"Dark red",VT(5,5,0))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
 	 	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.75, 0.75, -1) * ANGLES(RAD(0), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Weapon.Parent = Character
		CreateSound(633627961, Character, 5, 1, false)
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Fugatrix"
		SKILLTEXTCOLOR = C3(0.05,0,0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		tecks2.Text = "Dominus Fugatrix"
		Speed = 30
	elseif MODE == "Fugatrix" then
		Weapon.Parent = nil
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
   WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function DeathForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Fugatrix" then
		sick.SoundId = "rbxassetid://2650791818"
		sick.Volume = 10
		sick.Pitch = 0.97
		sick.TimePosition = 0
		-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		for i=0, 2, 0.1 / Animation_Speed do
			Swait()
			CreateRing(VT(0,0,0.1),false,0,15,CF(HITPOS)*ANGLES(RAD(90),RAD(0),RAD(0)),"Maroon",VT(5,5,0))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
 	 	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.75, 0.75, -1) * ANGLES(RAD(0), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Weapon.Parent = nil
		CreateSound(145080998, Character, 5, 1, false)
	for i=0, 1, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Mortem"
		SKILLTEXTCOLOR = C3(0.1,0,0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		tecks2.Text = "Dominus Mortem"
		Speed = 30
	elseif MODE == "Mortem" then
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
    WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function CreateParticles(art,text,accel,drag,lifetime,type,isenabledbydefault,locked)
	local particle = nil
	coroutine.resume(coroutine.create(function(PART)
		particle = PE:Clone()
		Swait()
		particle.Rate = 999
		particle.Parent = art
		particle.Acceleration = accel
		if type == "Fire" then
			local EyeSizes={
				NumberSequenceKeypoint.new(0,0.5,0.3),
				NumberSequenceKeypoint.new(1,0.2,0.2)
			}
			particle.Size = NumberSequence.new(EyeSizes)
		elseif type == "Smoke" then
			local EyeSizes={
				NumberSequenceKeypoint.new(0,0.5,0),
				NumberSequenceKeypoint.new(1,5,0.5)
			}
			particle.Size = NumberSequence.new(EyeSizes)
		elseif type == "Solid" then
			local EyeSizes={
				NumberSequenceKeypoint.new(0,0.5,0),
				NumberSequenceKeypoint.new(1,0.5,0)
			}
			particle.Size = NumberSequence.new(EyeSizes)
		end
		particle.Lifetime=NumberRange.new(lifetime)
		particle.Drag = drag
		if locked == true then
			particle.LockedToPart = true
		end
		particle.Texture = "http://www.roblox.com/asset/?id="..text
		particle.Enabled = isenabledbydefault
	end))
return particle
end

local MAGICPARTICLE = "296874871"

local Plate = IT("Part",LMAO)
Plate.Size = VT(1,0.1,1)
Plate.Transparency = 1
Plate.CanCollide = false
Plate.CFrame = RightArm.CFrame * CF(0,-1.1,0)
CreateParticles(Plate,MAGICPARTICLE,VT(0,2,0),2,2,"Fire",true,true)
weldBetween(RightArm,Plate)
Plate.Parent = nil

local Plate = IT("Part",LMAO)
Plate.Size = VT(1,0.1,1)
Plate.Transparency = 1
Plate.CanCollide = false
Plate.CFrame = LeftArm.CFrame * CF(0,-1.1,0)
CreateParticles(Plate,MAGICPARTICLE,VT(0,2,0),2,2,"Fire",true,true)
weldBetween(LeftArm,Plate)
Plate.Parent = nil

function FinalForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Main" then
		sick.SoundId = "rbxassetid://576172702"
		sick.Volume = 10
		sick.Pitch = 0.97
		sick.TimePosition = 0
		-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		for i=0, 2, 50 / Animation_Speed do
			Swait()
			Slice("Round", 0, 45, CF(RightArm.CFrame * CF(0, MRANDOM(-3, -2), 0).p) * ANGLES(RAD(0), RAD(MRANDOM(-180, 180)), RAD(0)), "Pearl", VT(0.01, 0, 0.01) * MRANDOM(2, 3))
			MagicSphere(VT(0, 0, 0), 15, CF(RightArm.CFrame * CF(0, -1.2, 0).p, RightArm.CFrame * CF(MRANDOM(-5, 5), -1.2 + MRANDOM(-25, 25), MRANDOM(-5, 5)).p), C3(0.5, 0.5, 1), VT(1, 0.1, 0.1))
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	LMAO.Parent = Character
	for i = 1, 25 do
			Swait()
			Slice("Round", 0, 45, CF(RootPart.Position + VT(0, MRANDOM(-5, 15), 0)) * ANGLES(RAD(MRANDOM(-18, 18)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-18, 18))), "Pearl", VT(0.1, 0, 0.1) * MRANDOM(2, 3))
			Slice("Thin", 0, 65, CF(RootPart.Position + VT(0, MRANDOM(-5, 15), 0)) * ANGLES(RAD(MRANDOM(-18, 18)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-18, 18))), "Pearl", VT(0.1, 0, 0.1) * MRANDOM(2, 3))
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Maris"
		SKILLTEXTCOLOR = C3(0,0,1)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		tecks2.Text = "Dominus Maris"
		Speed = 80
	elseif MODE == "Maris" then
	LMAO.Parent = nil
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
    WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function DeForm()
	ATTACK = true
	Rooted = true
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
	if MODE == "Praefectus" then
		sick.SoundId = "rbxassetid://1633982099"
		sick.Volume = 10
		sick.Pitch = 0.97
		sick.TimePosition = 1
	-- Animation --
		coroutine.resume(coroutine.create(function()
		end))
		CreateSound(1238240145, Torso, 6, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)

			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		MODE = "Demonum"
		tecks2.Text = "Dominus Daemonium"
		SKILLTEXTCOLOR = C3(0.03, 0, 0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		Speed = 30
	elseif MODE == "Demonum" then
		CreateSound(147722227, Torso, 4, 1.3, false)
		sick.SoundId = "rbxassetid://195900687"
		sick.Volume = 4
		sick.Pitch = 1
		sick.TimePosition = 20.7
    WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(500,0.11,500)*SIZE, Size2 = VT(0,0.11,0), Transparency = 1, Transparency2 = 0, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 255/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		WACKYEFFECT({Time = 37.5, EffectType = "Sphere", Size = VT(0.5,0.5,0.5), Size2 = VT(75,75,75), Transparency = 0, Transparency2 = 0.5, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0/255, 0/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
        Swait(15)
		Speed = 16
		MODE = "Main"
		BodyColor = C3(0,0,0)
		LegColor = C3(0,0,0.05)
		ArmColor = C3(0.05,0.05,0.15)
	end
	ATTACK = false
	Rooted = false
end

function Ignem_Aeternum()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if HITFLOOR ~= nil then
		do
			local POWER = LEVEL
			ATTACK = true
			Rooted = true
			local CENTER = MagicRing()
			CENTER.CFrame = CF(HITPOS + VT(0, 0.1, 0))
			CreateSound("424777055", CENTER, 10, 1)
			local RAIN = {}
			for i = 1, 55 do
				Swait()
				CENTER.Size = CENTER.Size + VT(POWER, 0, POWER) / 3
				CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local MAXDIST = 30
			local DIRECTION = CF(RootPart.Position, VT(Mouse.Hit.p.X, HITPOS.Y, Mouse.Hit.p.Z)).lookVector
			local HITFLOOR2, HITPOS2 = Raycast(RootPart.Position, DIRECTION, MAXDIST, Character)
			local HITFLOOR3, HITPOS3 = Raycast(HITPOS2, CF(HITPOS2 + VT(0, 1, 0), HITPOS2 + VT(0, -1, 0)).lookVector, MAXDIST, Character)
			local ORB = CreatePart(3, Effects, "Neon", 0, 1, "Gold", "ORB", VT(4, 4, 4))
			MakeForm(ORB, "Ball")
			CreateSound("201858045", ORB, 10, 0.5)
			for i = 0, 1, 0.1 / Animation_Speed do
				Swait()
				ORB.CFrame = RootPart.CFrame * CF(0, 10 + POWER * 3, 0)
				ORB.Transparency = 0
				ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 7
				local POS = HITPOS + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 0, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3))
				local RANGE = (POS - RootPart.CFrame * CF(0, 10 + POWER * 3, 0).p).Magnitude
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				ORB.CFrame = CF(ORB.Position, HITPOS3)
				local IMPACT = false
				for i = 1, 400 do
					Swait()
					ORB.CFrame = ORB.CFrame * CF(0, 0, -1)
					local HIT = Raycast(ORB.Position, ORB.CFrame.lookVector, ORB.Size.X / 2.2, Character)
					if HIT ~= nil then
						IMPACT = true
						break
					end
				end
				if IMPACT == true then
					ORB.Transparency = 1
					local FRONT = ORB.CFrame * CF(0, 0, -1).p
					ORB.CFrame = CF(ORB.Position, VT(FRONT.X, ORB.Position.Y, FRONT.Z))
					for i = 1, 35 do
						ORB.CFrame = ORB.CFrame * CF(0, 0, -ORB.Size.X / 1.5)
						MagicSphere(ORB.Size * 1.1, 25, ORB.CFrame, BRICKC("Gold").Color, -ORB.Size / 35)
						CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ORB.Position - VT(0, ORB.Size.Y / 3, 0)) * ANGLES(RAD(0), RAD(i * 5), RAD(0)), true, 5, "Gold", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
						killnearest(ORB.Position, ORB.Size.X * 2, 500)
						Swait()
					end
				else
					ORB:remove()
				end
			end))
			ATTACK = false
			Rooted = false
			coroutine.resume(coroutine.create(function()
				for i = 1, 55 do
					Swait()
					CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
					CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
				end
				CENTER:remove()
			end))
		end
	end
end

function Dead_Cutter()
    local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
    if HITFLOOR ~= nil then
        ATTACK = true
        Rooted = true
		local RAIN = {}
        local GYRO = IT("BodyGyro",RootPart)
        GYRO.D = 100
        GYRO.P = 2000
        GYRO.MaxTorque = VT(0,4000000,0)
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
        CreateSound("429459101", RightArm, 10, 0.8)
        for i=0, 3.5, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            Slice("Thin",0.3,5,RightArm.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),"Really red",VT(-0.01,0,-0.01))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(-15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        GYRO:remove()
        for i=0, 0.15, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            Slice("Thin",0.3,5,RightArm.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),"Really red",VT(-0.01,0,-0.01))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        local BOMBSPOTS = {}
        for i = 1, 60 do
            local SPOT = CreatePart(3, Effects, "Neon", 0, 0, "Relly blue", "Blade", VT(30,1,30))
            SPOT.Color = SKILLTEXTCOLOR
            SPOT.CFrame = RootPart.CFrame*CF((MRANDOM(-15,15)/40)*i,-5,-i*5)
            table.insert(BOMBSPOTS,SPOT)
            MakeForm(SPOT,"Cyl")
		Swait()
		for i = 1, 3 do
		coroutine.resume(coroutine.create(function()
			local DROP = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Raindrop", VT(2 / 2, 2 / 2, 2 * 5))
			DROP.CFrame = CF(SPOT.Position + VT(MRANDOM(-SPOT.Size.X / 3, SPOT.Size.X / 3), 200, MRANDOM(-SPOT.Size.X / 3, SPOT.Size.X / 3)), SPOT.Position + VT(MRANDOM(-SPOT.Size.X / 2.5, SPOT.Size.X / 2.5), 0, MRANDOM(-SPOT.Size.X / 2.5, SPOT.Size.X / 2.5)))
			table.insert(RAIN, DROP)
			MakeForm(DROP, "Ball")
			local IMPACT = false
			for i = 1, 80 do
				Swait()
				DROP.CFrame = DROP.CFrame * CF(0, 0, -7)
				local HIT = Raycast(DROP.Position, DROP.CFrame.lookVector, 6, Character)
				if HIT ~= nil then
					IMPACT = true
					break
				end
			end
			table.remove(RAIN, 1)
			if IMPACT == true then
				DROP.Transparency = 1
				MagicSphere(VT(0, 0, 0), 25, DROP.CFrame, BRICKC("Really red").Color, VT(2, 2, 2) / 2)
				killnearest(DROP.Position, 2 * 5, 500)
				Debris:AddItem(DROP, 5)
			else
				DROP:remove()
			end
		end))
		end
        end
        for i=0, 0.2, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(145), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        ATTACK = false
        Rooted = false
        coroutine.resume(coroutine.create(function()
            Swait(3)
            for i = 1, #BOMBSPOTS do
                if BOMBSPOTS[i] ~= nil then
                    local E = BOMBSPOTS[i]
                    coroutine.resume(coroutine.create(function()
                        for i = 1, 10 do
                            Swait()
                        end
                        Swait(45)
                        for i = 1, 100 do
                            Swait()
                        end
                        E:remove()
                    end))
                end
            end
        end))
    end
end
 

function Ultimate_B()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if HITFLOOR ~= nil then
		do
			local POWER = 3
			ATTACK = true
			Rooted = true
			local CENTER = MagicRing()
			CENTER.CFrame = CF(HITPOS + VT(0, 0.1, 0))
			CreateSound("424777055", CENTER, 10, 1)
			local RAIN = {}
			for i = 1, 55 do
				Swait()
				CENTER.Size = CENTER.Size + VT(POWER, 0, POWER) / 3
				CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			local MAXDIST = 30
			local DIRECTION = CF(RootPart.Position, VT(Mouse.Hit.p.X, HITPOS.Y, Mouse.Hit.p.Z)).lookVector
			local HITFLOOR2, HITPOS2 = Raycast(RootPart.Position, DIRECTION, MAXDIST, Character)
			local HITFLOOR3, HITPOS3 = Raycast(HITPOS2, CF(HITPOS2 + VT(0, 1, 0), HITPOS2 + VT(0, -1, 0)).lookVector, MAXDIST, Character)
			local ORB = CreatePart(3, Effects, "Neon", 0, 1, "Gold", "ORB", VT(4, 4, 4))
			MakeForm(ORB, "Ball")
			CreateSound("201858045", ORB, 10, 0.5)
			for i = 0, 1, 0.1 / Animation_Speed do
				Swait()
				ORB.CFrame = RootPart.CFrame * CF(0, 10 + POWER * 3, 0)
				ORB.Transparency = 0
				ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 7
				local POS = HITPOS + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 0, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3))
				local RANGE = (POS - RootPart.CFrame * CF(0, 10 + POWER * 3, 0).p).Magnitude
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				ORB.CFrame = CF(ORB.Position, HITPOS3)
				local IMPACT = false
				for i = 1, 400 do
					Swait()
					ORB.CFrame = ORB.CFrame * CF(0, 0, -1)
					local HIT = Raycast(ORB.Position, ORB.CFrame.lookVector, ORB.Size.X / 2.2, Character)
					if HIT ~= nil then
						IMPACT = true
						break
					end
				end
				if IMPACT == true then
					ORB.Transparency = 1
					local FRONT = ORB.CFrame * CF(0, 0, -1).p
					ORB.CFrame = CF(ORB.Position, VT(FRONT.X, ORB.Position.Y, FRONT.Z))
					for i = 1, 35 do
						ORB.CFrame = ORB.CFrame * CF(0, 0, -ORB.Size.X / 1.5)
						MagicSphere(ORB.Size * 1.1, 25, ORB.CFrame, BRICKC("Gold").Color, -ORB.Size / 35)
						CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ORB.Position - VT(0, ORB.Size.Y / 3, 0)) * ANGLES(RAD(0), RAD(i * 5), RAD(0)), true, 5, "Gold", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
						killnearest(ORB.Position, ORB.Size.X * 2, 500)
						Swait()
					end
				else
					ORB:remove()
				end
			end))
	for i = 1, 70 do
		Swait()
		coroutine.resume(coroutine.create(function()
			local DROP = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "Raindrop", VT(POWER / 2, POWER / 2, POWER * 5))
			DROP.CFrame = CF(ORB.Position + VT(MRANDOM(-ORB.Size.X / 3, ORB.Size.X / 3), 200, MRANDOM(-ORB.Size.X / 3, ORB.Size.X / 3)), ORB.Position + VT(MRANDOM(-ORB.Size.X / 2.5, ORB.Size.X / 2.5), 0, MRANDOM(-ORB.Size.X / 2.5, ORB.Size.X / 2.5)))
			table.insert(RAIN, DROP)
			particles(DROP)
			MakeForm(DROP, "Ball")
			local IMPACT = false
			for i = 1, 80 do
				Swait()
				DROP.CFrame = DROP.CFrame * CF(0, 0, -7)
				local HIT = Raycast(DROP.Position, DROP.CFrame.lookVector, 6, Character)
				if HIT ~= nil then
					IMPACT = true
					break
				end
			end
			table.remove(RAIN, 1)
			if IMPACT == true then
				DROP.Transparency = 1
				DROP.OVERLORDAURA.Enabled = false
				MagicSphere(VT(0, 0, 0), 25, DROP.CFrame, BRICKC("Gold").Color, VT(POWER, POWER, POWER) / 2)
				killnearest(DROP.Position, POWER * 5, 500)
				Debris:AddItem(DROP, 5)
			else
				DROP:remove()
			end
		end))
	end
			ATTACK = false
			Rooted = false
			coroutine.resume(coroutine.create(function()
				for i = 1, 55 do
					Swait()
					CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
					CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
				end
				CENTER:remove()
			end))
		end
	end
end

function Dolor_Pluvia()
	local POWER = LEVEL
	local CENTER = MagicRing()
	CENTER.CFrame = CF(Mouse.Hit.p)
	CreateSound("424777055", CENTER, 10, 1)
	local RAIN = {}
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	for i = 1, 35 do
		Swait()
		coroutine.resume(coroutine.create(function()
			local DROP = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "Raindrop", VT(POWER / 2, POWER / 2, POWER * 5))
			DROP.CFrame = CF(CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 200, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3)), CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5), 0, MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5)))
			table.insert(RAIN, DROP)
			particles(DROP)
			MakeForm(DROP, "Ball")
			local IMPACT = false
			for i = 1, 80 do
				Swait()
				DROP.CFrame = DROP.CFrame * CF(0, 0, -7)
				local HIT = Raycast(DROP.Position, DROP.CFrame.lookVector, 6, Character)
				if HIT ~= nil then
					IMPACT = true
					break
				end
			end
			table.remove(RAIN, 1)
			if IMPACT == true then
				DROP.Transparency = 1
				DROP.OVERLORDAURA.Enabled = false
				MagicSphere(VT(0, 0, 0), 25, DROP.CFrame, BRICKC("Gold").Color, VT(POWER, POWER, POWER) / 2)
				killnearest(DROP.Position, POWER * 5, 500)
				Debris:AddItem(DROP, 5)
			else
				DROP:remove()
			end
		end))
	end
	repeat
		Swait()
	until #RAIN == 0
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	CENTER:remove()
end

function Ultimate_Z()
	local POWER = 5
	local CENTER = MagicRing()
	CENTER.CFrame = CF(Mouse.Hit.p)
	CreateSound("424777055", CENTER, 10, 1)
	local RAIN = {}
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	for i = 1, 100 do
		Swait()
		coroutine.resume(coroutine.create(function()
			local DROP = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "Raindrop", VT(POWER / 2, POWER / 2, POWER * 5))
			DROP.CFrame = CF(CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 200, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3)), CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5), 0, MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5)))
			table.insert(RAIN, DROP)
			particles(DROP)
			MakeForm(DROP, "Ball")
			local IMPACT = false
			for i = 1, 80 do
				Swait()
				DROP.CFrame = DROP.CFrame * CF(0, 0, -7)
				local HIT = Raycast(DROP.Position, DROP.CFrame.lookVector, 6, Character)
				if HIT ~= nil then
					IMPACT = true
					break
				end
			end
			table.remove(RAIN, 1)
			if IMPACT == true then
				DROP.Transparency = 1
				DROP.OVERLORDAURA.Enabled = false
				MagicSphere(VT(0, 0, 0), 25, DROP.CFrame, BRICKC("Gold").Color, VT(POWER, POWER, POWER) / 2)
				killnearest(DROP.Position, POWER * 5, 500)
				Debris:AddItem(DROP, 5)
			else
				DROP:remove()
			end
		end))
	end
	repeat
		Swait()
	until #RAIN == 0
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	CENTER:remove()
end

function Ultima_Consummatio()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7, Character)
	if HITFLOOR ~= nil then
		do
			local POWER = LEVEL
			ATTACK = true
			Rooted = true
			if POWER <= 6 then
				do
					local CENTER = MagicRing()
					CENTER.CFrame = CF(HITPOS + VT(0, 0.1, 0))
					CreateSound("424777055", CENTER, 10, 1)
					local RAIN = {}
					for i = 1, 65 do
						Swait()
						CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
						CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ORB = CreatePart(3, Effects, "Neon", 0, 1, "Gold", "ORB", VT(4, 4, 4))
					MakeForm(ORB, "Ball")
					CreateSound("201858045", ORB, 10, 0.5)
					for i = 0, 5, 0.1 / Animation_Speed do
						Swait()
						ORB.CFrame = RootPart.CFrame * CF(0, 5 + ORB.Size.Y / 2, 0)
						ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 10
						ORB.Transparency = 0
						local POS = HITPOS + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 0, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3))
						local RANGE = (POS - ORB.Position).Magnitude
						local ZAPTABLE = Zap({
							StartPosition = POS,
							TargetPosition = ORB.Position,
							Character = workspace,
							Color = "Gold",
							Individual = true,
							MaxRange = RANGE,
							SegmentLength = POWER * 2,
							Offset = 1
						})
						Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					coroutine.resume(coroutine.create(function()
						if POWER <= 3 then
							local AIMPOS = Mouse.Hit.p
							local O1 = MagicRing()
							local O2 = MagicRing()
							local O3 = MagicRing()
							O1.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
							O2.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
							O3.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
							for i = 1, 25 do
								Swait()
								O1.Size = O1.Size + VT(POWER, 0, POWER)
								O2.Size = O2.Size + VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size + VT(POWER, 0, POWER) / 2
							end
							local DIST = (ORB.Position - AIMPOS).Magnitude
							for i = 1, 75 do
								Swait(3)
								CreateRing(VT(0, 0, 0), false, 0, 45, CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
								killnearest(ORB.Position, ORB.Size.X, 200)
								local ZAPTABLE = Zap({
									SIZE = POWER * 2,
									StartPosition = ORB.Position,
									TargetPosition = AIMPOS + VT(MRANDOM(-POWER * 15, POWER * 15), 0, MRANDOM(-POWER * 15, POWER * 15)) * 2,
									Character = Character,
									Color = "Gold",
									Individual = true,
									MaxRange = POWER * 400,
									SegmentLength = DIST / 25,
									Offset = 3 + DIST / 350
								})
								Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								MagicSphere(ORB.Size * 1.1, 25, CF(ZAPTABLE.RayPos), BRICKC("Gold").Color, ORB.Size / 15)
								killnearest(ZAPTABLE.RayPos, POWER * 45, 60)
								CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ZAPTABLE.RayPos), true, 5, "Gold", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
							end
							local SIZE = ORB.Size
							for i = 1, 25 do
								Swait()
								ORB.Size = ORB.Size - SIZE / 25
								O1.Size = O1.Size - VT(POWER, 0, POWER)
								O2.Size = O2.Size - VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size - VT(POWER, 0, POWER) / 2
							end
							ORB:remove()
							O1:remove()
							O2:remove()
							O3:remove()
						elseif POWER > 3 then
							local O1 = MagicRing()
							local O2 = MagicRing()
							local O3 = MagicRing()
							O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
							O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
							O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
							for i = 1, 25 do
								Swait()
								O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
								O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
								O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
								O1.Size = O1.Size + VT(POWER, 0, POWER)
								O2.Size = O2.Size + VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size + VT(POWER, 0, POWER) / 2
							end
							for i = 1, 75 do
								for i = 1, 5 do
									Swait()
									O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
									O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
									O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
								end
								killnearest(ORB.Position, ORB.Size.X, 200)
								CreateRing(VT(0, 0, 0), false, 0, 45, CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
								local DIST = (ORB.Position - Mouse.Hit.p).Magnitude
								local ZAPTABLE = Zap({
									SIZE = POWER,
									StartPosition = ORB.Position,
									TargetPosition = Mouse.Hit.p,
									Character = Character,
									Color = "Gold",
									Individual = true,
									MaxRange = POWER * 400,
									SegmentLength = DIST / 25,
									Offset = 3 + DIST / 350
								})
								Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								MagicSphere(ORB.Size * 1.1, 25, CF(ZAPTABLE.RayPos), BRICKC("Gold").Color, ORB.Size / 15)
								killnearest(ZAPTABLE.RayPos, POWER * 45, 60)
								CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ZAPTABLE.RayPos), true, 5, "Gold", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
							end
							local SIZE = ORB.Size
							for i = 1, 25 do
								Swait()
								ORB.Size = ORB.Size - SIZE / 25
								O1.Size = O1.Size - VT(POWER, 0, POWER)
								O2.Size = O2.Size - VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size - VT(POWER, 0, POWER) / 2
							end
							ORB:remove()
							O1:remove()
							O2:remove()
							O3:remove()
						end
						coroutine.resume(coroutine.create(function()
							for i = 1, 65 do
								Swait()
								CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
								CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
							end
							CENTER:remove()
						end))
					end))
				end
			elseif POWER > 6 then
				do
					local FINISHED = false
					local YIN = CreatePart(3, Effects, "Neon", 0, 0, "Pearl", "YIN", VT(25, 25, 25))
					local YAN = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "YAN", VT(65, 25, 65))
					coroutine.resume(coroutine.create(function()
						local LOOP = 0
						repeat
							YIN.CFrame = CF(HITPOS + VT(0, 500, 0)) * ANGLES(RAD(0), RAD(LOOP), RAD(0)) * CF(0, 0, 200)
							YAN.CFrame = CF(HITPOS + VT(0, 500, 0)) * ANGLES(RAD(0), RAD(LOOP), RAD(0)) * CF(0, 0, -200)
							LOOP = LOOP + 5
							MagicSphere(VT(500, 5, 500), 65, CF(YIN.Position), BRICKC("Gold").Color, VT(-1, -0.001, -1) * 2)
							MagicSphere(VT(500, 5, 500), 65, CF(YAN.Position), C3(1, 1, 1), VT(-1, -0.001, -1) * 2)
							Swait()
						until FINISHED == true
						YIN:remove()
						YAN:remove()
					end))
					CreateSound("438666077", Effects, 10, 1)
					for i = 0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(65), RAD(0), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(65), RAD(0), RAD(-90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ORB = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "ORB", VT(6, 6, 6))
					MakeForm(ORB, "Ball")
					ORB.CFrame = CF(HITPOS + VT(0, 150, 0))
					for i = 0, 8, 0.1 / Animation_Speed do
						Swait()
						if MRANDOM(1, 8) == 1 then
							local RANGE1 = (ORB.Position - YIN.Position).Magnitude
							local RANGE2 = (ORB.Position - YAN.Position).Magnitude
							local ZAPTABLE1 = Zap({
								SIZE = POWER / 3,
								StartPosition = YIN.Position,
								TargetPosition = ORB.Position,
								Character = workspace,
								Color = "Pearl",
								Individual = true,
								MaxRange = RANGE1,
								SegmentLength = 25,
								Offset = 6
							})
							local ZAPTABLE2 = Zap({
								SIZE = POWER / 3,
								StartPosition = YAN.Position,
								TargetPosition = ORB.Position,
								Character = workspace,
								Color = "Gold",
								Individual = true,
								MaxRange = RANGE1,
								SegmentLength = 25,
								Offset = 6
							})
							Debris:AddItem(ZAPTABLE1.LightningModel, 0.1)
							Debris:AddItem(ZAPTABLE2.LightningModel, 0.1)
						end
						ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 15
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					FINISHED = true
					coroutine.resume(coroutine.create(function()
						for i = 1, 6 do
							for e = 1, 10 do
								Swait()
								Slice("Thin", ORB.Size.X / 15, 15, ORB.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Pearl", VT(-0.01, 0, -0.01))
								ORB.Size = ORB.Size * 0.97
								killnearest(ORB.Position, ORB.Size.X * 3, 200)
								CreateWave(VT(ORB.Size.X, 35, ORB.Size.X), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5 + e * 5), RAD(0)), false, 0, C3(1, 1, 1), VT(POWER, 0, POWER))
							end
							local POS = ORB.Position
							for i = 1, 5 do
								CreateRing(VT(0, 0, 0), false, 0, 8 * i, CF(POS) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
							end
							CreateRing(VT(0, 0, 0), false, 0, 45, CF(POS) * ANGLES(RAD(90), RAD(0), RAD(0)), C3(1, 1, 1), VT(POWER, POWER, 0))
							for e = 1, 10 do
								Swait()
								if MRANDOM(1, 5) == 1 then
									local POS = CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))) * CF(0, 0, -POWER * 25).p
									local ZAPTABLE = Zap({
										SIZE = POWER,
										StartPosition = ORB.Position,
										TargetPosition = POS,
										Character = workspace,
										Color = "Gold",
										Individual = true,
										MaxRange = POWER * 75,
										SegmentLength = POWER * 5,
										Offset = 3
									})
									Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								end
								ORB.Size = ORB.Size * 1.05
								killnearest(ORB.Position, ORB.Size.X * 3, 200)
								CreateWave(VT(ORB.Size.X, 35, ORB.Size.X), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5 + e * 5), RAD(0)), false, 0, C3(1, 1, 1), VT(POWER, 0, POWER))
							end
						end
						local POS = ORB.Position
						for e = 1, 10 do
							Swait()
							ORB.Transparency = ORB.Transparency + 0.1
						end
						ORB:remove()
						killnearest(POS, POWER * 35, 200)
						for i = 1, 5 do
							CreateRing(VT(0, 0, 0), false, 0, 8 * i, CF(POS) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
						end
						CreateRing(VT(0, 0, 0), false, 0, 45, CF(POS) * ANGLES(RAD(90), RAD(0), RAD(0)), C3(1, 1, 1), VT(POWER, POWER, 0))
					end))
				end
			end
			ATTACK = false
			Rooted = false
		end
	end
end

function Hop()
	ATTACK = true
	Rooted = false
	local O1 = MagicRing()
	local O2 = MagicRing()
	local POS = VT(RootPart.Position.X, Mouse.Hit.p.Y + 6, RootPart.Position.Z)
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	O2.CFrame = CF(Mouse.Hit.p + VT(0, 6, 0), POS) * ANGLES(RAD(90), RAD(0), RAD(0))
	local ROOT = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	ROOT.CFrame = CF(O2.Position, RootPart.Position)
	CreateSound("814168787", O1, 10, 0.7)
	CreateSound("814168787", O2, 10, 0.7)
	for i = 1, 75 do
		Swait()
		O1.Size = O1.Size + VT(0.15, 0, 0.15)
		O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(i), RAD(0))
		O2.Size = O2.Size + VT(0.15, 0, 0.15)
		O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.35 + 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(90), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	Rooted = true
	UNANCHOR = false
	RootPart.Anchored = true
	VALUE1 = true
	for i = 1, 15 do
		Transparency(i / 15)
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.13)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	RootPart.CFrame = ROOT.CFrame
	ROOT:remove()
	for i = 1, 15 do
		Transparency(1 - i / 15)
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.5)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	VALUE1 = false
	coroutine.resume(coroutine.create(function()
		for i = 1, 75 do
			Swait()
			O1.Size = O1.Size - VT(0.15, 0, 0.15)
			O1.CFrame = O1.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
			O2.Size = O2.Size - VT(0.15, 0, 0.15)
			O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		end
		O1:remove()
		O2:remove()
	end))
	UNANCHOR = true
	RootPart.Anchored = false
	ATTACK = false
	Rooted = false
end

local ATANIM = IT("Animation")
ATANIM.Name = "Attack Animation"
ATANIM.AnimationId = "http://www.roblox.com/asset/?id=74894663"

function SummonHop()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if HITFLOOR ~= nil then
	ATTACK = true
	Rooted = false
	local O1 = MagicRing()
	local O2 = MagicRing()
	local POS = VT(RootPart.Position.X, Mouse.Hit.p.Y + 6, RootPart.Position.Z)
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	O2.CFrame = CF(Mouse.Hit.p)
	local ROOT = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	ROOT.CFrame = CF(O2.Position, RootPart.Position)
	CreateSound("814168787", O1, 10, 0.7)
	CreateSound("814168787", O2, 10, 0.7)
	for i = 1, 75 do
		Swait()
		O1.Size = O1.Size + VT(0.15, 0, 0.15)
		O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(i), RAD(0))
		O2.Size = O2.Size + VT(0.15, 0, 0.15)
		O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(25 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(140), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-25 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	Rooted = true
	UNANCHOR = false
	RootPart.Anchored = true
	VALUE1 = true
			local RANDOMEFFECT = MRANDOM(1,1)
			if RANDOMEFFECT == 1 then
				for i = 1, 10 do
					wait(0.15)
					WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(3,8,3), Transparency = 0, Transparency2 = 1, CFrame = O2.CFrame*CF(0,0.3,0), MoveToPos = O2.Position+VT(0,6,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 90655239, SoundPitch = 0.8, SoundVolume = 6})
					coroutine.resume(coroutine.create(function()
						local MINION = CLONE:Clone()
						MINION.Parent = Effects
						MINION.Name = "Shadow"
						MINION.HumanoidRootPart.CFrame = O2.CFrame*CF(0,5,0) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0))
						MINION.HumanoidRootPart.Velocity = CF(MINION.HumanoidRootPart.Position,MINION.HumanoidRootPart.CFrame*CF(0,8,-15).p).lookVector*MRANDOM(55,100)
						for _, c in pairs(MINION:GetChildren()) do
							if c.ClassName == "Part" then
								c.Material = "Neon"
								c.Color = C3(0,0,0)
								c.Transparency = 0.25
								if c.Name == "Head" then
									c:ClearAllChildren()
									local MSH = IT("BlockMesh",c)
									MSH.Scale = VT(0.5,1,1)
								end
							end
						end
						local TORSO = MINION.Torso
						local HUMAN = MINION.Humanoid
						HUMAN.WalkSpeed = 20
						HUMAN.MaxHealth = math.huge
						HUMAN.Health = math.huge
						HUMAN.DisplayDistanceType = "None"
						HUMAN.Died:connect(function()
							MINION:remove()
							--CreateSound(SHOUTS[MRANDOM(1,3)], TORSO, 3, 0.5, false)
						end)
						wait(1)
						local findNearestTorso = function(POS)
							local list = game.Workspace:GetDescendants()
							local torso = nil
							local dist = 500
							local temp = nil
							local human = nil
							local temp2 = nil
							for x = 1, #list do
								temp2 = list[x]
								if (temp2.className == "Model") and (temp2 ~= Character) and (temp2.Parent ~= Effects) then
									temp = temp2:findFirstChild("Torso") or temp2:findFirstChild("UpperTorso")
									human = temp2:findFirstChildOfClass("Humanoid")
									if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
										if (temp.Position - POS).magnitude < dist then
											torso = temp
											dist = (temp.Position - POS).magnitude
										end
									end
								end
							end
							return torso, dist
						end
						for i = 1, 20 do
							if HUMAN.Health == 0 then
								break
							end
							wait(0.3)
							local target,dist= findNearestTorso(TORSO.Position)
							if target then
								HUMAN:MoveTo(target.Position)
								if dist < 25 then
									CreateSound(348663022, TORSO, 10, 1, true)
									wait(2)
									local ANIM = HUMAN:LoadAnimation(ATANIM)
									ANIM:Play()
									--CreateSound(SHOUTS[MRANDOM(1,3)], TORSO, 1, 1, false)
									killnearest(TORSO.Position,10,85)
									WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(5,5,5), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = 201858087, SoundPitch = 0.8, SoundVolume = 10})
									for i = 1, 5 do
										WACKYEFFECT({Time = 75, EffectType = "Wave", Size = VT(5,0,5)*SIZE, Size2 = VT(15,1,15), Transparency = 0.5, Transparency2 = 1, CFrame = TORSO.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-15,15)/7.5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
									end
									break
								end
							end
						end
						MINION:remove()
					end))
				end
				end
	VALUE1 = false
	coroutine.resume(coroutine.create(function()
		for i = 1, 75 do
			Swait()
			O1.Size = O1.Size - VT(0.15, 0, 0.15)
			O1.CFrame = O1.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
			O2.Size = O2.Size - VT(0.15, 0, 0.15)
			O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		end
		O1:remove()
		O2:remove()
	end))
	UNANCHOR = true
	RootPart.Anchored = false
	ATTACK = false
	Rooted = false
end
end

function Dark_Cutter()
    local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
    if HITFLOOR ~= nil then
        ATTACK = true
        Rooted = true
        local GYRO = IT("BodyGyro",RootPart)
        GYRO.D = 100
        GYRO.P = 2000
        GYRO.MaxTorque = VT(0,4000000,0)
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
        CreateSound("429459101", RightArm, 10, 0.8)
        for i=0, 3.5, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            Slice("Thin",0.3,5,RightArm.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),"Really black",VT(-0.01,0,-0.01))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(-15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        GYRO:remove()
        for i=0, 0.15, 0.1 / Animation_Speed do
            Swait()
            GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
            Slice("Thin",0.3,5,RightArm.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),"Really black",VT(-0.01,0,-0.01))
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        local BOMBSPOTS = {}
        for i = 1, 100 do
            local SPOT = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Blade", VT(16,1,16))
            SPOT.CFrame = RootPart.CFrame*CF((MRANDOM(-15,15)/40)*i,-5,-i*5)
            table.insert(BOMBSPOTS,SPOT)
            MakeForm(SPOT,"Cyl")
        end
        for i=0, 0.2, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(145), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        ATTACK = false
        Rooted = false
        coroutine.resume(coroutine.create(function()
            Swait(3)
            for i = 1, #BOMBSPOTS do
                if BOMBSPOTS[i] ~= nil then
                    local E = BOMBSPOTS[i]
                    coroutine.resume(coroutine.create(function()
                        local BLADE = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Really black", "Blade", VT(0,0,0))
                        CreateMesh("SpecialMesh", BLADE, "FileMesh", "93108071", "", VT(1.2,2,0.8)*3, VT(0,0,0))
                        CreateSound(HITWEAPONSOUNDS[MRANDOM(1,#HITWEAPONSOUNDS)], BLADE, 4, 0.6)
                        BLADE.CFrame = E.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-15,15)),RAD(90),RAD(MRANDOM(-15,15)))
                        for i = 1, 10 do
                            Swait()
                           killnearest(BLADE.Position,12,160)
                            BLADE.CFrame = BLADE.CFrame*CF(0,0.3,0)
                            BLADE.Transparency = BLADE.Transparency - 0.1
                        end
                        Swait(45)
                        for i = 1, 100 do
                            Swait()
                            BLADE.Transparency = BLADE.Transparency + 0.01
                            E.Transparency = E.Transparency + 0.01
                        end
                        BLADE:remove()
                        E:remove()
                    end))
                end
            end
        end))
    end
end

function SupernovaThrow()
    local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
    if HITFLOOR ~= nil then
        local HITBODIES = {}
        ATTACK = true
        Rooted = true
        local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "Really black", "Star", VT(0,0,0))
        MakeForm(ABSOLUTE,"Ball")
        CreateSound("429459101", ABSOLUTE, 10, 1)
        for i=0, 4, 0.1 / Animation_Speed do
            Swait()
            ABSOLUTE.Size = ABSOLUTE.Size + VT(0.2,0.2,0.2)
            ABSOLUTE.CFrame = RootPart.CFrame*CF(0,5+(ABSOLUTE.Size.Y/2),0)
            ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        CreateSound("907330103", Head, 10, 1.2)
        for i = 1, 75 do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        coroutine.resume(coroutine.create(function()
		ABSOLUTE.CFrame = CF(ABSOLUTE.Position, Mouse.Hit.p)
		for i = 1, 500 do
			Swait()
			ABSOLUTE.CFrame = ABSOLUTE.CFrame * CF(0, 0, -2)
			local HITFLOOR, HITPOS = Raycast(ABSOLUTE.Position, ABSOLUTE.CFrame.lookVector, 2.2, Character)
			if HITFLOOR ~= nil then
				break
			end
		end
            for i = 1, 13 do
                for e = 1, 8 do
                    Swait()
                    CreateSwirl(ABSOLUTE.Size/2,15,CF(HITPOS),true,15,BRICKC"Slime green".Color,VT(i,0.3,i)*2)
                end
                for i = 1, 5 do
                    Slice("Round",0,35,CF(ABSOLUTE.Position)*ANGLES(RAD(MRANDOM(-18,18)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-18,18))),C3(1,1,1),VT(i,0,i)/3)
                    Slice("Thin",i,55,ABSOLUTE.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),C3(1,0,0),VT(0,0,0))
                end
                CreateSwirl(ABSOLUTE.Size/2,25,CF(ABSOLUTE.Position),true,-25,BRICKC"Relly red".Color,VT(i,i*2,i))
                CreateSwirl(ABSOLUTE.Size/2,55,CF(ABSOLUTE.Position),true,25,C3(0.05,0.05,0.05),VT(i,i*2,i))
                CreateSound("168586621", ABSOLUTE, 4, 0.8)
                CreateSound("201858144", ABSOLUTE, 10, 0.8)
                killnearest(ABSOLUTE.Position,i*18,i)
                ABSOLUTE.Size = ABSOLUTE.Size*0.9
                MagicSphere(ABSOLUTE.Size,25,CF(ABSOLUTE.Position),BRICKC"Relly red".Color,VT(i,i,i)/1.1)
                MagicSphere(ABSOLUTE.Size,45,CF(ABSOLUTE.Position),C3(0.05,0.05,0.05),VT(i,i,i))
            end
            ABSOLUTE.Transparency = 1
            Debris:AddItem(ABSOLUTE,10)
        end))
        ATTACK = false
        Rooted = false
    end
end

function Dark_Blast()
    local HITBODIES = {}
    local CENTER = CreatePart(3, Effects, "SmoothPlastic", 0, 1, "Relly red", "CenterPart", VT(0,0,0))
    local HITFLOOR,ECH,NORMAL = Raycast(Mouse.Hit.p+VT(0,2,0), (CF(Mouse.Hit.p, Mouse.Hit.p + VT(0, -1, 0))).lookVector, 10000000, Character)
    CENTER.CFrame = CF(ECH)
    local RAY = CreatePart(3, Effects, "Neon", 0, 1, "Relly red", "Laser01", VT(25,99999,25))
    RAY.Color = C3(0.05,0.05,0.05)
    MakeForm(RAY,"Cyl")
    RAY.CFrame = CF(ECH)
    for i = 1, 75 do
        Swait()
        RAY.Transparency = RAY.Transparency - 1/75
        RAY.Size = RAY.Size - VT(25/75,0,25/75)
    end
    killnearest(ECH,50,25)
    MagicSphere(VT(0,0,0),55,CF(ECH),C3(0.05,0.05,0.05),VT(2,2,2))
    for i = 1, 50 do
    end
    CreateSound("1222405264", CENTER, 10, 0.8)
    RAY:remove()
    Debris:AddItem(CENTER,5)
end

function Banisher_Bullet()
	ATTACK = true
	Rooted = false
	for i=0, 0.4, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	repeat
		for i=0, 0.2, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(Hole2.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(Hole2.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Hole2.CFrame, MoveToPos = Hole2.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Hole2.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole2.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole2.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(106), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function Dead_Bullet()
	ATTACK = true
	Rooted = false
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	repeat
		for i=0, 0.1, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.1, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(106), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function Ruler2()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		do
			local HITBODIES = {}
			ATTACK = true
			Rooted = true
			local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "Dark red", "SuperNova", VT(0, 0, 0))
			MakeForm(ABSOLUTE, "Ball")
			CreateSound("814168787", ABSOLUTE, 10, 0.3)
			for i = 0, 4, 0.1 / Animation_Speed do
				Swait()
				ABSOLUTE.Size = ABSOLUTE.Size + VT(0.2, 0.2, 0.2)
				ABSOLUTE.CFrame = RootPart.CFrame * CF(0, 5 + ABSOLUTE.Size.Y / 2, 0)
				ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
				local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Star", VT(1, 1, 1))
				MakeForm(CHARGE, "Ball")
				CHARGE.Color = C3(0, 0, 0)
				CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15, 15), -6, MRANDOM(-15, 15))
				FireArc(CHARGE, ABSOLUTE.Position, 45, 45, true)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			CreateSound("907333406", Head, 10, 1)
			for i = 0, 2, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
				local PITS = {}
				CreateSound("178452217", ABSOLUTE, 10, 0.7)
				for i = 1, 6 do
					for i = 1, 10 do
						Swait()
						Slice("Thin", ABSOLUTE.Size.X / 20, 15, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really black", VT(-0.01, 0, -0.01))
						ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					end
					for i = 1, 10 do
						Swait()
						ABSOLUTE.Size = ABSOLUTE.Size * 1.12
					end
				end
				CreateSound("215395388", ABSOLUTE, 10, 0.6)
				CreateSound("215395388", ABSOLUTE, 10, 0.65)
				CreateSound("215395388", ABSOLUTE, 10, 0.7)
				for i = 1, 75 do
					Swait()
					local ICICLE = IT("CornerWedgePart", Effects)
					ICICLE.Locked = true
					ICICLE.CanCollide = false
					ICICLE.Anchored = true
					ICICLE.Color = C3(0, 0, 0)
					ICICLE.Material = "Neon"
					ICICLE.Size = VT(i / 3, i * 2, i / 3)
					ICICLE.CFrame = CF(HITPOS) * CF(MRANDOM(-ABSOLUTE.Size.X, ABSOLUTE.Size.X), 0, MRANDOM(-ABSOLUTE.Size.X / 1.5, ABSOLUTE.Size.X / 1.5)) * ANGLES(RAD(MRANDOM(-25, 25)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-25, 25)))
					table.insert(PITS, ICICLE)
					killnearest(ICICLE.Position, ICICLE.Size.Y / 1.5, -100)
					ABSOLUTE.Size = ABSOLUTE.Size * 1.03
					killnearest(ABSOLUTE.Position, ABSOLUTE.Size.X / 1.9, -100)
					for i = 1, 3 do
						Slice("Thin", ABSOLUTE.Size.X / 20, 5, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really black", VT(-0.01, 0, -0.01))
					end
					CreateWave(VT(ABSOLUTE.Size.X / 1.5, 35, ABSOLUTE.Size.X / 1.5), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5), RAD(0)), false, 0, C3(0, 0, 0), VT(i / 3, 0, i / 3))
				end
				ABSOLUTE.Transparency = 0
				for i = 1, 10 do
					Swait()
					ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					ABSOLUTE.Transparency = ABSOLUTE.Transparency + 0.1
				end
				Debris:AddItem(ABSOLUTE, 5)
				Swait(50)
				for i = 1, 10 do
					Swait()
					for e = 1, #PITS do
						if PITS[e] ~= nil then
							local E = PITS[e]
							E.Transparency = E.Transparency + 0.1
						end
					end
				end
				for e = 1, #PITS do
					if PITS[e] ~= nil then
						local E = PITS[e]
						E:remove()
					end
				end
			ATTACK = false
			Rooted = false
		end
	end
end

function Ultima_ConsummatioB()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7, Character)
	if HITFLOOR ~= nil then
		do
			local POWER = 20
			ATTACK = true
			Rooted = true
			if POWER <= 6 then
				do
					local CENTER = MagicRing()
					CENTER.CFrame = CF(HITPOS + VT(0, 0.1, 0))
					CreateSound("424777055", CENTER, 10, 1)
					local RAIN = {}
					for i = 1, 65 do
						Swait()
						CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
						CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ORB = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "ORB", VT(4, 4, 4))
					MakeForm(ORB, "Ball")
					CreateSound("201858045", ORB, 10, 0.5)
					for i = 0, 5, 0.1 / Animation_Speed do
						Swait()
						ORB.CFrame = RootPart.CFrame * CF(0, 5 + ORB.Size.Y / 2, 0)
						ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 10
						ORB.Transparency = 0
						local POS = HITPOS + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 0, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3))
						local RANGE = (POS - ORB.Position).Magnitude
						local ZAPTABLE = Zap({
							StartPosition = POS,
							TargetPosition = ORB.Position,
							Character = workspace,
							Color = "Really red",
							Individual = true,
							MaxRange = RANGE,
							SegmentLength = POWER * 2,
							Offset = 1
						})
						Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					coroutine.resume(coroutine.create(function()
						if POWER <= 3 then
							local AIMPOS = Mouse.Hit.p
							local O1 = MagicRing()
							local O2 = MagicRing()
							local O3 = MagicRing()
							O1.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
							O2.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
							O3.CFrame = CF(ORB.Position, AIMPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
							for i = 1, 25 do
								Swait()
								O1.Size = O1.Size + VT(POWER, 0, POWER)
								O2.Size = O2.Size + VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size + VT(POWER, 0, POWER) / 2
							end
							local DIST = (ORB.Position - AIMPOS).Magnitude
							for i = 1, 75 do
								Swait(3)
								CreateRing(VT(0, 0, 0), false, 0, 45, CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
								killnearest(ORB.Position, ORB.Size.X, 200)
								local ZAPTABLE = Zap({
									SIZE = POWER * 2,
									StartPosition = ORB.Position,
									TargetPosition = AIMPOS + VT(MRANDOM(-POWER * 15, POWER * 15), 0, MRANDOM(-POWER * 15, POWER * 15)) * 2,
									Character = Character,
									Color = "Really red",
									Individual = true,
									MaxRange = POWER * 400,
									SegmentLength = DIST / 25,
									Offset = 3 + DIST / 350
								})
								Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								MagicSphere(ORB.Size * 1.1, 25, CF(ZAPTABLE.RayPos), BRICKC("Really red").Color, ORB.Size / 15)
								killnearest(ZAPTABLE.RayPos, POWER * 45, 60)
								CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ZAPTABLE.RayPos), true, 5, "Really red", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
							end
							local SIZE = ORB.Size
							for i = 1, 25 do
								Swait()
								ORB.Size = ORB.Size - SIZE / 25
								O1.Size = O1.Size - VT(POWER, 0, POWER)
								O2.Size = O2.Size - VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size - VT(POWER, 0, POWER) / 2
							end
							ORB:remove()
							O1:remove()
							O2:remove()
							O3:remove()
						elseif POWER > 3 or POWER == 3 then
							local O1 = MagicRing()
							local O2 = MagicRing()
							local O3 = MagicRing()
							O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
							O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
							O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
							for i = 1, 25 do
								Swait()
								O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
								O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
								O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
								O1.Size = O1.Size + VT(POWER, 0, POWER)
								O2.Size = O2.Size + VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size + VT(POWER, 0, POWER) / 2
							end
							for i = 1, 75 do
								for i = 1, 5 do
									Swait()
									O1.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X, 0)
									O2.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 4, 0)
									O3.CFrame = CF(ORB.Position, Mouse.Hit.p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -ORB.Size.X + ORB.Size.X / 8, 0)
								end
								killnearest(ORB.Position, ORB.Size.X, 200)
								CreateRing(VT(0, 0, 0), false, 0, 45, CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
								local DIST = (ORB.Position - Mouse.Hit.p).Magnitude
								local ZAPTABLE = Zap({
									SIZE = POWER,
									StartPosition = ORB.Position,
									TargetPosition = Mouse.Hit.p,
									Character = Character,
									Color = "Really red",
									Individual = true,
									MaxRange = POWER * 400,
									SegmentLength = DIST / 25,
									Offset = 3 + DIST / 350
								})
								Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								MagicSphere(ORB.Size * 1.1, 25, CF(ZAPTABLE.RayPos), BRICKC("Really red").Color, ORB.Size / 15)
								killnearest(ZAPTABLE.RayPos, POWER * 45, 60)
								CreateWave(VT(ORB.Size.X, 1, ORB.Size.Z) * 5, 35, CF(ZAPTABLE.RayPos), true, 5, "Really red", -VT(ORB.Size.X / 24, 0, ORB.Size.Z / 24))
							end
							local SIZE = ORB.Size
							for i = 1, 25 do
								Swait()
								ORB.Size = ORB.Size - SIZE / 25
								O1.Size = O1.Size - VT(POWER, 0, POWER)
								O2.Size = O2.Size - VT(POWER, 0, POWER) / 1.5
								O3.Size = O3.Size - VT(POWER, 0, POWER) / 2
							end
							ORB:remove()
							O1:remove()
							O2:remove()
							O3:remove()
						end
						coroutine.resume(coroutine.create(function()
							for i = 1, 65 do
								Swait()
								CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
								CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
							end
							CENTER:remove()
						end))
					end))
				end
			elseif POWER > 6 then
				do
					local FINISHED = false
					local YIN = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "YIN", VT(25, 25, 25))
					local YAN = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "YAN", VT(65, 25, 65))
					coroutine.resume(coroutine.create(function()
						local LOOP = 0
						repeat
							YIN.CFrame = CF(HITPOS + VT(0, 500, 0)) * ANGLES(RAD(0), RAD(LOOP), RAD(0)) * CF(0, 0, 200)
							YAN.CFrame = CF(HITPOS + VT(0, 500, 0)) * ANGLES(RAD(0), RAD(LOOP), RAD(0)) * CF(0, 0, -200)
							LOOP = LOOP + 5
							MagicSphere(VT(500, 5, 500), 65, CF(YIN.Position), BRICKC("Really red").Color, VT(-1, -0.001, -1) * 2)
							MagicSphere(VT(500, 5, 500), 65, CF(YAN.Position), C3(0, 0, 0), VT(-1, -0.001, -1) * 2)
							Swait()
						until FINISHED == true
						YIN:remove()
						YAN:remove()
					end))
					CreateSound("438666077", Effects, 10, 1)
					for i = 0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(65), RAD(0), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(65), RAD(0), RAD(-90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ORB = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "ORB", VT(6, 6, 6))
					MakeForm(ORB, "Ball")
					ORB.CFrame = CF(HITPOS + VT(0, 150, 0))
					for i = 0, 8, 0.1 / Animation_Speed do
						Swait()
						if MRANDOM(1, 8) == 1 then
							local RANGE1 = (ORB.Position - YIN.Position).Magnitude
							local RANGE2 = (ORB.Position - YAN.Position).Magnitude
							local ZAPTABLE1 = Zap({
								SIZE = POWER / 3,
								StartPosition = YIN.Position,
								TargetPosition = ORB.Position,
								Character = workspace,
								Color = "Pearl",
								Individual = true,
								MaxRange = RANGE1,
								SegmentLength = 25,
								Offset = 6
							})
							local ZAPTABLE2 = Zap({
								SIZE = POWER / 3,
								StartPosition = YAN.Position,
								TargetPosition = ORB.Position,
								Character = workspace,
								Color = "Really red",
								Individual = true,
								MaxRange = RANGE1,
								SegmentLength = 25,
								Offset = 6
							})
							Debris:AddItem(ZAPTABLE1.LightningModel, 0.1)
							Debris:AddItem(ZAPTABLE2.LightningModel, 0.1)
						end
						ORB.Size = ORB.Size + VT(POWER, POWER, POWER) / 15
						RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(0)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-90 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					FINISHED = true
					coroutine.resume(coroutine.create(function()
						for i = 1, 6 do
							for e = 1, 10 do
								Swait()
								Slice("Thin", ORB.Size.X / 15, 15, ORB.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Pearl", VT(-0.01, 0, -0.01))
								ORB.Size = ORB.Size * 0.97
								killnearest(ORB.Position, ORB.Size.X * 3, 200)
								CreateWave(VT(ORB.Size.X, 35, ORB.Size.X), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5 + e * 5), RAD(0)), false, 0, C3(1, 1, 1), VT(POWER, 0, POWER))
							end
							local POS = ORB.Position
							for i = 1, 5 do
								CreateRing(VT(0, 0, 0), false, 0, 8 * i, CF(POS) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
							end
							CreateRing(VT(0, 0, 0), false, 0, 45, CF(POS) * ANGLES(RAD(90), RAD(0), RAD(0)), C3(1, 1, 1), VT(POWER, POWER, 0))
							for e = 1, 10 do
								Swait()
								if MRANDOM(1, 5) == 1 then
									local POS = CF(ORB.Position) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))) * CF(0, 0, -POWER * 25).p
									local ZAPTABLE = Zap({
										SIZE = POWER,
										StartPosition = ORB.Position,
										TargetPosition = POS,
										Character = workspace,
										Color = "Really red",
										Individual = true,
										MaxRange = POWER * 75,
										SegmentLength = POWER * 5,
										Offset = 3
									})
									Debris:AddItem(ZAPTABLE.LightningModel, 0.1)
								end
								ORB.Size = ORB.Size * 1.05
								killnearest(ORB.Position, ORB.Size.X * 3, 200)
								CreateWave(VT(ORB.Size.X, 35, ORB.Size.X), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5 + e * 5), RAD(0)), false, 0, C3(1, 1, 1), VT(POWER, 0, POWER))
							end
						end
						local POS = ORB.Position
						for e = 1, 10 do
							Swait()
							ORB.Transparency = ORB.Transparency + 0.1
						end
						ORB:remove()
						killnearest(POS, POWER * 35, 200)
						for i = 1, 5 do
							CreateRing(VT(0, 0, 0), false, 0, 8 * i, CF(POS) * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), C3(1, 1, 1), VT(POWER, POWER, 0) / 5)
						end
						CreateRing(VT(0, 0, 0), false, 0, 45, CF(POS) * ANGLES(RAD(90), RAD(0), RAD(0)), C3(1, 1, 1), VT(POWER, POWER, 0))
					end))
				end
			end
			ATTACK = false
			Rooted = false
			local POWER = 1
		end
	end
end

function Banish_Hop()
    ATTACK = true
    Rooted = false
    local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0,0,0))
    O1.CFrame = RootPart.CFrame*CF(0,0,-3)*ANGLES(RAD(90),RAD(0),RAD(0))
    local decal = Decal:Clone()
    decal.Parent = O1
    decal.Face = "Top"
    decal.Texture = "http://www.roblox.com/asset/?id=106410100"
    local decal2 = Decal:Clone()
    decal2.Parent = O1
    decal2.Face = "Bottom"
    decal2.Texture = "http://www.roblox.com/asset/?id=106410100"
    local O2 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0,0,0))
    local POS = VT(RootPart.Position.X,Mouse.Hit.p.Y+6,RootPart.Position.Z)
    O2.CFrame = CF(Mouse.Hit.p+VT(0,6,0),POS)*ANGLES(RAD(90),RAD(0),RAD(0))
    local ROOT = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0,0,0))
    ROOT.CFrame = CF(O2.Position,RootPart.Position)
    local decal = Decal:Clone()
    decal.Parent = O2
    decal.Face = "Top"
    decal.Texture = "http://www.roblox.com/asset/?id=106410100"
    local decal2 = Decal:Clone()
    decal2.Parent = O2
    decal2.Face = "Bottom"
    decal2.Texture = "http://www.roblox.com/asset/?id=106410100"
    CreateSound("84005018", O1, 10, 0.7)
    CreateSound("84005018", O2, 10, 0.7)
    for i = 1, 75 do
        Swait()
        O1.Size = O1.Size + VT(0.1,0,0.1)
        O1.CFrame = RootPart.CFrame*CF(0,0,-3)*ANGLES(RAD(90),RAD(i),RAD(0))
        O2.Size = O2.Size + VT(0.1,0,0.1)
        O2.CFrame = O2.CFrame*ANGLES(RAD(0),RAD(i),RAD(0))
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(90), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
    end
    Rooted = true
    UNANCHOR = false
    RootPart.Anchored = true
    VALUE1 = true
    for i = 1, 15 do
        Transparency(i/15)
        Swait()
        RootPart.CFrame = RootPart.CFrame*CF(0,0,-0.13)
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
    end
    RootPart.CFrame = ROOT.CFrame
    ROOT:remove()
    for i = 1, 15 do
        Transparency(1-(i/15))
        Swait()
        RootPart.CFrame = RootPart.CFrame*CF(0,0,-0.5)
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
    end
    VALUE1 = false
    coroutine.resume(coroutine.create(function()
        for i = 1, 75 do
            Swait()
            O1.Size = O1.Size - VT(0.1,0,0.1)
            O1.CFrame = O1.CFrame*ANGLES(RAD(0),RAD(i),RAD(0))
            O2.Size = O2.Size - VT(0.1,0,0.1)
            O2.CFrame = O2.CFrame*ANGLES(RAD(0),RAD(i),RAD(0))
        end
        O1:remove()
        O2:remove()
    end))
    UNANCHOR = true
    RootPart.Anchored = false
    ATTACK = false
    Rooted = false
end

function Governor_Bomb()
	local CENTER = CreatePart(3, Effects, "SmoothPlastic", 0, 1, C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), "CenterPart", VT(0, 0, 0))
	local RAY = CreatePart(3, Effects, "Neon", 0, 1, C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), "Laser01", VT(25, 25, 25))
	RAY.Color = C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549)
	MakeForm(RAY, "Ball")
	local ECH = Mouse.Hit.p
	CENTER.CFrame = CF(Mouse.Hit.p)
	RAY.CFrame = CENTER.CFrame
	CreateSound("814168787", CENTER, 10, 0.6)
	for i = 1, 80 do
		Swait()
		RAY.Size = RAY.Size * 0.98
		RAY.Transparency = RAY.Transparency - 0.016666666666666666
	end
	killnearest(ECH, 25, 250)
	MagicSphere(VT(1, 1, 1), 55, CF(ECH), C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), VT(2, 2, 2))
	MagicSphere(VT(0, 0, 0), 45, CF(ECH), C3(0, 0, 0), VT(2, 2, 2))
	CreateSound("314970790", CENTER, 10, 1)
	Debris:AddItem(CENTER, 5)
	RAY:remove()
end
function Governor_Bomb2()
	local CENTER = CreatePart(3, Effects, "SmoothPlastic", 0, 1, C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), "CenterPart", VT(0, 0, 0))
	local RAY = CreatePart(3, Effects, "Neon", 0, 1, C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), "Laser01", VT(25, 25, 25))
	RAY.Color = C3(0.96078431372549, 0.019803921568627451, 0.0196078431372549)
	MakeForm(RAY, "Ball")
	local ECH = Mouse.Hit.p
	CENTER.CFrame = CF(Mouse.Hit.p)
	RAY.CFrame = CENTER.CFrame
	CreateSound("814168787", CENTER, 10, 0.6)
	for i = 1, 80 do
		Swait()
		RAY.Size = RAY.Size * 0.98
		RAY.Transparency = RAY.Transparency - 0.016666666666666666
	end
	killnearest(ECH, 25, 250)
	MagicSphere(VT(1, 1, 1), 55, CF(ECH), C3(0.96078431372549, 0.019803921568627451, 0.0196078431372549), VT(2, 2, 2))
	MagicSphere(VT(0, 0, 0), 45, CF(ECH), C3(0, 0, 0), VT(2, 2, 2))
	CreateSound("314970790", CENTER, 10, 1)
	Debris:AddItem(CENTER, 5)
	RAY:remove()
end
function Governor_Bomb3()
	local ABSOLUTE = CreatePart(3, Effects, "SmoothPlastic", 0, 1, C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116), "CenterPart", VT(50, 50, 50))
	local RAY = CreatePart(3, Effects, "Neon", 0, 1, C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), "Laser01", VT(75, 75, 75))
	RAY.Color = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
	MakeForm(RAY, "Ball")
	local ECH = Mouse.Hit.p
	ABSOLUTE.CFrame = CF(Mouse.Hit.p)
	local HITFLOOR, HITPOS, NORMAL = Raycast(ABSOLUTE.Position, CF(ABSOLUTE.Position, ABSOLUTE.Position + VT(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	RAY.CFrame = ABSOLUTE.CFrame
	CreateSound("814168787", ABSOLUTE, 10, 0.6)
	for i = 1, 80 do
		Swait()
		RAY.Size = RAY.Size * 0.98
		RAY.Transparency = RAY.Transparency - 0.016666666666666666
	end
			coroutine.resume(coroutine.create(function()
				local PITS = {}
				CreateSound("178452217", ABSOLUTE, 10, 0.7)
				for i = 1, 6 do
					for i = 1, 10 do
						Swait()
						Slice("Thin", ABSOLUTE.Size.X / 20, 15, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really white", VT(-0.01, 0, -0.01))
						ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					end
					for i = 1, 10 do
						Swait()
						ABSOLUTE.Size = ABSOLUTE.Size * 1.12
					end
				end
				CreateSound("215395388", ABSOLUTE, 10, 0.6)
				CreateSound("215395388", ABSOLUTE, 10, 0.65)
				CreateSound("215395388", ABSOLUTE, 10, 0.7)
				for i = 1, 75 do
					Swait()
					local ICICLE = IT("CornerWedgePart", Effects)
					ICICLE.Locked = true
					ICICLE.CanCollide = false
					ICICLE.Anchored = true
					ICICLE.Color = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
					ICICLE.Material = "Neon"
					ICICLE.Size = VT(i / 3, i * 2, i / 3)
					ICICLE.CFrame = CF(HITPOS) * CF(MRANDOM(-ABSOLUTE.Size.X, ABSOLUTE.Size.X), 0, MRANDOM(-ABSOLUTE.Size.X / 1.5, ABSOLUTE.Size.X / 1.5)) * ANGLES(RAD(MRANDOM(-25, 25)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-25, 25)))
					table.insert(PITS, ICICLE)
					killnearest(ICICLE.Position, ICICLE.Size.Y / 1.5, -100)
					ABSOLUTE.Size = ABSOLUTE.Size * 1.03
					killnearest(ABSOLUTE.Position, ABSOLUTE.Size.X / 1.9, -100)
					for i = 1, 3 do
						Slice("Thin", ABSOLUTE.Size.X / 20, 5, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really black", VT(-0.01, 0, -0.01))
					end
				end
				ABSOLUTE.Transparency = 0
				for i = 1, 10 do
					Swait()
					ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					ABSOLUTE.Transparency = ABSOLUTE.Transparency + 0.1
				end
				Debris:AddItem(ABSOLUTE, 5)
				Swait(50)
				for i = 1, 10 do
					Swait()
					for e = 1, #PITS do
						if PITS[e] ~= nil then
							local E = PITS[e]
							E.Transparency = E.Transparency + 0.1
						end
					end
				end
				for e = 1, #PITS do
					if PITS[e] ~= nil then
						local E = PITS[e]
						E:remove()
					end
				end
			end))
	MagicSphere(VT(1, 1, 1), 55, CF(ECH), C3(1, 1, 1), VT(2, 2, 2))
	MagicSphere(VT(0, 0, 0), 45, CF(ECH), C3(1, 1, 1), VT(2, 2, 2))
	CreateSound("314970790", ABSOLUTE, 10, 1)
	Debris:AddItem(ABSOLUTE, 5)
	RAY:remove()
end
function Command_Rush()
	ATTACK = true
	Rooted = false
	for i = 0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(25 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(140), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-25 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	Rooted = true
	local GYRO = IT("BodyGyro", RootPart)
	GYRO.D = 100
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0, 4000000, 0)
	GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
	for i = 1, 15 do
		for i = 1, 15 do
			Swait()
			GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(25 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(140), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-25 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		coroutine.resume(coroutine.create(function()
			local EYE = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Eyeball", VT(0, 0, 0))
			CreateSound("814168787", EYE, 10, 1)
			EYE.CFrame = RootPart.CFrame * CF(MRANDOM(-15, 15), MRANDOM(8, 20), MRANDOM(-15, 15))
			local M = CreateMesh("SpecialMesh", EYE, "FileMesh", "82326541", "82327419", VT(0, 0, 0), VT(0, 0, 0))
			MagicSphere(VT(0, 0, 0), 15, CF(EYE.Position), C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), VT(1, 1, 1))
			local ATTACKI = false
			local TORS
			for i = 1, 10 do
				Swait()
				M.Scale = M.Scale + VT(0.1, 0.1, 0.1) * 3
				EYE.CFrame = EYE.CFrame * CF(0, 0, -0.5)
			end
			for i = 1, 100 do
				Swait()
				for _, c in pairs(workspace:GetChildren()) do
					if c.ClassName == "Model" and c ~= Character and c:FindFirstChildOfClass("Humanoid") and (c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) then
						local HUMANOID = c:FindFirstChildOfClass("Humanoid")
						if 0 < HUMANOID.Health then
							local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
							if (TORSO.Position - EYE.Position).Magnitude < 35 then
								ATTACKI = true
								TORS = TORSO
							end
						end
					end
				end
				if ATTACKI == true then
					break
				end
				EYE.CFrame = EYE.CFrame * CF(0, 0, -1)
			end
			if ATTACKI == false then
				for i = 1, 10 do
					Swait()
					M.Scale = M.Scale - VT(0.1, 0.1, 0.1) * 3
					EYE.CFrame = EYE.CFrame * CF(0, 0, -0.5)
				end
			else
				if TORS ~= nil then
					CreateSound("215395388", EYE, 10, 2)
					local DIST = (TORS.Position - EYE.Position).Magnitude
					MagicSphere(VT(0, 0, 0), 15, CF(EYE.Position), C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), VT(1, 1, 1))
					MagicSphere(VT(1, 1, DIST), 15, CF(EYE.Position, TORS.Position) * CF(0, 0, -DIST / 2), C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), VT(0, 0, 0))
					MagicSphere(VT(0, 0, 0), 15, CF(TORS.Position), C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549), VT(1, 1, 1))
					EYE.CFrame = CF(EYE.Position, TORS.Position)
					TORS.Parent:BreakJoints()
					Swait(35)
				end
				for i = 1, 10 do
					Swait()
					M.Scale = M.Scale - VT(0.1, 0.1, 0.1) * 3
				end
			end
			EYE:remove()
		end))
	end
	GYRO:remove()
	ATTACK = false
	Rooted = false
end
function Ruler()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		do
			local HITBODIES = {}
			ATTACK = true
			Rooted = true
			local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "SuperNova", VT(0, 0, 0))
			ABSOLUTE.Color = C3(0.0196078431372549, 0.09803921568627451, 0.0196078431372549)
			MakeForm(ABSOLUTE, "Ball")
			CreateSound("814168787", ABSOLUTE, 10, 0.3)
			for i = 0, 4, 0.1 / Animation_Speed do
				Swait()
				ABSOLUTE.Size = ABSOLUTE.Size + VT(0.2, 0.2, 0.2)
				ABSOLUTE.CFrame = RootPart.CFrame * CF(0, 5 + ABSOLUTE.Size.Y / 2, 0)
				ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
				local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Star", VT(1, 1, 1))
				MakeForm(CHARGE, "Ball")
				CHARGE.Color = C3(0, 0, 0)
				CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15, 15), -6, MRANDOM(-15, 15))
				FireArc(CHARGE, ABSOLUTE.Position, 45, 45, true)
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			CreateSound("907333406", Head, 10, 1)
			for i = 0, 2, 0.1 / Animation_Speed do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				local PITS = {}
				CreateSound("178452217", ABSOLUTE, 10, 0.7)
				for i = 1, 6 do
					for i = 1, 10 do
						Swait()
						Slice("Thin", ABSOLUTE.Size.X / 20, 15, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really black", VT(-0.01, 0, -0.01))
						ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					end
					for i = 1, 10 do
						Swait()
						ABSOLUTE.Size = ABSOLUTE.Size * 1.12
					end
				end
				CreateSound("215395388", ABSOLUTE, 10, 0.6)
				CreateSound("215395388", ABSOLUTE, 10, 0.65)
				CreateSound("215395388", ABSOLUTE, 10, 0.7)
				for i = 1, 75 do
					Swait()
					local ICICLE = IT("CornerWedgePart", Effects)
					ICICLE.Locked = true
					ICICLE.CanCollide = false
					ICICLE.Anchored = true
					ICICLE.Color = C3(0, 0, 0)
					ICICLE.Material = "Neon"
					ICICLE.Size = VT(i / 3, i * 2, i / 3)
					ICICLE.CFrame = CF(HITPOS) * CF(MRANDOM(-ABSOLUTE.Size.X, ABSOLUTE.Size.X), 0, MRANDOM(-ABSOLUTE.Size.X / 1.5, ABSOLUTE.Size.X / 1.5)) * ANGLES(RAD(MRANDOM(-25, 25)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-25, 25)))
					table.insert(PITS, ICICLE)
					killnearest(ICICLE.Position, ICICLE.Size.Y / 1.5, -100)
					ABSOLUTE.Size = ABSOLUTE.Size * 1.03
					killnearest(ABSOLUTE.Position, ABSOLUTE.Size.X / 1.9, -100)
					for i = 1, 3 do
						Slice("Thin", ABSOLUTE.Size.X / 20, 5, ABSOLUTE.CFrame * ANGLES(RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-180, 180))), "Really black", VT(-0.01, 0, -0.01))
					end
					CreateWave(VT(ABSOLUTE.Size.X / 1.5, 35, ABSOLUTE.Size.X / 1.5), 25, CF(HITPOS) * ANGLES(RAD(0), RAD(i * 5), RAD(0)), false, 0, C3(0, 0, 0), VT(i / 3, 0, i / 3))
				end
				ABSOLUTE.Transparency = 0
				for i = 1, 10 do
					Swait()
					ABSOLUTE.Size = ABSOLUTE.Size * 0.9
					ABSOLUTE.Transparency = ABSOLUTE.Transparency + 0.1
				end
				Debris:AddItem(ABSOLUTE, 5)
				Swait(50)
				for i = 1, 10 do
					Swait()
					for e = 1, #PITS do
						if PITS[e] ~= nil then
							local E = PITS[e]
							E.Transparency = E.Transparency + 0.1
						end
					end
				end
				for e = 1, #PITS do
					if PITS[e] ~= nil then
						local E = PITS[e]
						E:remove()
					end
				end
			end))
			ATTACK = false
			Rooted = false
		end
	end
end
local Decal = IT("Decal")
function Monarch_Hop()
	ATTACK = true
	Rooted = false
	local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	local decal = Decal:Clone()
	decal.Parent = O1
	decal.Face = "Top"
	decal.Texture = "http://www.roblox.com/asset/?id=332014171"
	local decal2 = Decal:Clone()
	decal2.Parent = O1
	decal2.Face = "Bottom"
	decal2.Texture = "http://www.roblox.com/asset/?id=332014171"
	local O2 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	local POS = VT(RootPart.Position.X, Mouse.Hit.p.Y + 6, RootPart.Position.Z)
	O2.CFrame = CF(Mouse.Hit.p + VT(0, 6, 0), POS) * ANGLES(RAD(90), RAD(0), RAD(0))
	local ROOT = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	ROOT.CFrame = CF(O2.Position, RootPart.Position)
	local decal = Decal:Clone()
	decal.Parent = O2
	decal.Face = "Top"
	decal.Texture = "http://www.roblox.com/asset/?id=332014171"
	local decal2 = Decal:Clone()
	decal2.Parent = O2
	decal2.Face = "Bottom"
	decal2.Texture = "http://www.roblox.com/asset/?id=332014171"
	CreateSound("84005018", O1, 10, 0.7)
	CreateSound("84005018", O2, 10, 0.7)
	for i = 1, 75 do
		Swait()
		O1.Size = O1.Size + VT(0.1, 0, 0.1)
		O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(i), RAD(0))
		O2.Size = O2.Size + VT(0.1, 0, 0.1)
		O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(90), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(90), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	Rooted = true
	UNANCHOR = false
	RootPart.Anchored = true
	VALUE1 = true
	for i = 1, 15 do
		Transparency(i / 15)
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.13)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	RootPart.CFrame = ROOT.CFrame
	ROOT:remove()
	for i = 1, 15 do
		Transparency(1 - i / 15)
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.5)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	VALUE1 = false
	coroutine.resume(coroutine.create(function()
		for i = 1, 75 do
			Swait()
			O1.Size = O1.Size - VT(0.1, 0, 0.1)
			O1.CFrame = O1.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
			O2.Size = O2.Size - VT(0.1, 0, 0.1)
			O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		end
		O1:remove()
		O2:remove()
	end))
	UNANCHOR = true
	RootPart.Anchored = false
	ATTACK = false
	Rooted = false
end

function Roar()
	ATTACK = true
	Rooted = true
	local VIOLENCE = 1
	if VIOLENCE <= 10 then
	MagicSphere(VT(0,0,0),15,Torso.CFrame,"Lime green",VT(2,2,2))
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.65*SIZE, 0*SIZE) * ANGLES(RAD(135), RAD(0), RAD(22)) * ANGLES(RAD(0), RAD(-70), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.65*SIZE, 0*SIZE) * ANGLES(RAD(135), RAD(0), RAD(-22)) * ANGLES(RAD(0), RAD(70), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
		local TAUNT = CreateSound(VOCALS_ENRAGES[MRANDOM(1,#VOCALS_ENRAGES)], Torso, 10, 1, false)
		repeat Swait() until TAUNT.TimeLength > 0
		repeat
			Swait()
			ApplyAoE(Torso.Position,15,0,0,200,false)
			local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
			WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,2,0), Size2 = VT(15,0,15), Transparency = 1, Transparency2 = 1, CFrame = CF(Head.Position) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = MRANDOM(9,11)/2})
			WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,2,0), Size2 = VT(35,0,35), Transparency = 0.2, Transparency2 = 1, CFrame = CF(HITPOS) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = MRANDOM(9,11)/2})
			TAUNT.Parent = Torso
		Swait()
		TAUNT.Parent = Torso
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Torso")
					if TORSO then
						if (TORSO.Position - Torso.Position).Magnitude <= 25 then
							WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(TORSO.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							TORSO:remove()
						end
					end
				end
			end
		end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, -0.2*SIZE, -0.1*SIZE) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
            Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(0,math.rad(-25),0)*ANGLES(math.rad(0 - 25 * math.cos(SINE / 0.1164)),math.rad(0 - 30 * math.cos(SINE / 0.25)),math.rad(0 - 30 * math.cos(SINE / 0.465))),.1)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0.1*SIZE) * ANGLES(RAD(-35), RAD(0), RAD(42)) * ANGLES(RAD(0), RAD(-70), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0.1*SIZE) * ANGLES(RAD(-35), RAD(0), RAD(-42)) * ANGLES(RAD(0), RAD(70), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(25), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(45), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		until TAUNT.TimePosition > TAUNT.TimeLength - 2
	end
	MagicSphere(VT(0,0,0),15,Torso.CFrame,"Lime green",VT(2,2,2))
	ATTACK = false
	Rooted = false
end

function Blizzard()
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		ATTACK = true
		Rooted = true
		local GYRO = IT("BodyGyro", RootPart)
		GYRO.D = 100
		GYRO.P = 2000
		GYRO.MaxTorque = VT(0, 4000000, 0)
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		for i = 0, 3.5, 0.1 / Animation_Speed do
			Swait()
			MagicSphere(VT(0, 0, 0), 15, CF(RightArm.CFrame * CF(0, -1.2, 0).p, RightArm.CFrame * CF(MRANDOM(-5, 5), -1.2 + MRANDOM(-25, 25), MRANDOM(-5, 5)).p), C3(0, 0, 0), VT(1, 0.1, 0.1) / 2)
			GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(-15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound("160772554", RightArm, 10, 0.7)
		for i = 0, 0.15, 0.1 / Animation_Speed do
			Swait()
			MagicSphere(VT(0, 0, 0), 15, CF(RightArm.CFrame * CF(0, -1.2, 0).p, RightArm.CFrame * CF(MRANDOM(-5, 5), -1.2 + MRANDOM(-25, 25), MRANDOM(-5, 5)).p), C3(0, 0, 0), VT(1, 0.1, 0.1) / 2)
			GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(90 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(5), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		coroutine.resume(coroutine.create(function()
			local CENTER = CreatePart(3, Effects, "SmoothPlastic", 0, 1, SKILLTEXTCOLOR, "CenterPart", VT(0, 0, 0))
			CENTER.CFrame = RootPart.CFrame
			for i = 1, 200 do
				Swait()
				CENTER.CFrame = CENTER.CFrame * CF(0, 0, -0.7)
				for i = 1, 2 do
					Slice("Round", 0, 45, CF(CENTER.Position + VT(0, MRANDOM(-15, 15), 0)) * ANGLES(RAD(MRANDOM(-18, 18)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-18, 18))), "Really red", VT(0.1, 0, 0.1) * MRANDOM(5, 15) / 10)
				end
				killnearest(CENTER.Position, 25, 10)
			end
			CENTER:remove()
		end))
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(85 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-85 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(145), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		Rooted = true
		GYRO:remove()
		ATTACK = false
		Rooted = false
	end
end

local INTRO = false
local INSTANT = false

function Intro()
	ATTACK = true
	Rooted = true
	MODE = "intro"
	tecks2.Text = "Dominus Switcher V2"
coroutine.resume(coroutine.create(function()
	    wait(6)
	BodyColor = C3(0,0,0)
	LegColor = C3(0.03, 0, 0)
	ArmColor = C3(0.13, 0, 0)
	WACKYEFFECT({EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(1,1,1)*2, Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BodyColor, SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = 6})
	
		CreateSound(147722227, Torso, 4, 1.3, false)
local eff = Instance.new("ParticleEmitter",Torso)
eff.Texture = "rbxassetid://2273224484"
eff.LightEmission = 1
eff.Color = ColorSequence.new(BrickColor.random().Color)
eff.Rate = 500000
eff.Lifetime = NumberRange.new(1,3)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,30,0),NumberSequenceKeypoint.new(0.2,5,0),NumberSequenceKeypoint.new(0.8,5,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0,0),NumberSequenceKeypoint.new(0.8,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(50,500)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-50,50)
	Swait(15)
		CreateSound(1187613212, Torso, 4, 1.3, false)

	WACKYEFFECT({EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(1,1,1)*2, Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BodyColor, SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = 6})
	
	 Swait(15)
		CreateSound(147722227, Torso, 4, 0.9, false)

	WACKYEFFECT({EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(1,1,1)*2, Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BodyColor, SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = 6})
	
	Swait(60)
		CreateSound(147722227, Torso, 4, 1, false)

	WACKYEFFECT({EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(1,1,1)*2, Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BodyColor, SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = 6})
	
	Swait(15)
		CreateSound(147722227, Torso, 4, 1.3, false)

	WACKYEFFECT({EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(1,1,1)*2, Transparency = 0, Transparency2 = 1, CFrame = CF(RightArm.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BodyColor, SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = 6})
	
	Swait(15)
		CreateSound(147722227, Torso, 4, 1.3, false)

    

	
	eff.Enabled = false
end))
Swait(15)
	repeat 
		Swait() 
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0.5 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(-3+3*COS(SINE/12)), RAD(0), RAD(9)), 1 / Animation_Speed)
			
			 Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-4 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			
			  RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.7 - 0.3 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2+4*COS(SINE/12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8 - 0.3 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2+7*COS(SINE/12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)

	until sick.TimePosition > 6
	repeat 
		Swait() 
		
	
		 Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(3 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			
		RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE - 0.1 * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(2.5 * COS(SINE / 12))), 0.8 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.1 * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0 - 2.5 * COS(SINE / 12))), 0.8 / Animation_Speed)
	

LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			
	
	until sick.TimePosition > 9
ATTACK = false
	Rooted = false
	MODE = "Main"
	end

local DAMAGEMULTIPLIER = 1

function ApplyDamage(Humanoid,Damage)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		Humanoid.Health = Humanoid.Health - Damage
	end
end

function Shatter(Part)
	if Part.Transparency < 1 then
		local SOUNDPART = CreatePart(3, Effects, "Glass", 0, Part.Transparency + 0.1, Part.BrickColor, "OOF", VT(0,0,0))
		Debris:AddItem(SOUNDPART,5)
		CreateSound("626807593", SOUNDPART, 3, MRANDOM(8,12)/10, false)
		local SIZE = Part.Size.X + Part.Size.Y + Part.Size.Z
		local SIZESET = SIZE/4
		local XOffset = Part.Size.X*1.5/SIZESET
		local YOffset = Part.Size.Y*1.5/SIZESET
		local ZOffset = Part.Size.Z*1.5/SIZESET
		for x = 1, math.ceil(XOffset) do
			for y = 1, math.ceil(YOffset) do
				for z = 1, math.ceil(ZOffset) do
					local SHARD = CreatePart(3, Effects, "Glass", 0, 0.15, Part.BrickColor, "Shard", VT(SIZE,SIZE,SIZE)/10, false)
					SHARD.CanCollide = true
					SHARD.CFrame = Part.CFrame*CF((Part.Size.X/2-Part.Size.X/4),(Part.Size.Y/2-Part.Size.Y/4),(Part.Size.Z/2-Part.Size.Z/4))
					SHARD.Velocity = VT(MRANDOM(-15,15),MRANDOM(-15,15),MRANDOM(-15,15))*3
					Debris:AddItem(SHARD,MRANDOM(10,25)/10)
					for _, c in pairs(Part:GetChildren()) do
						if c.ClassName == "ParticleEmitter" or c.ClassName == "PointLight" or c.ClassName == "Fire" then
							c:Clone().Parent = SHARD
						end
					end
				end
			end
		end
	end
	Part:remove()
end


function Kill(Victim,Fire)
	coroutine.resume(coroutine.create(function()
		local NIL = script.TotalNil:Clone()
		NIL.Parent = Victim
		NIL.Disabled = false
		if Fire ~= true then
			Victim:BreakJoints()
			for _, c in pairs(Victim:GetChildren()) do
				if c:IsA("BasePart") then
					c.Anchored = true
				end
			end
			for _, c in pairs(Victim:GetChildren()) do
				if c:IsA("BasePart") then
					Shatter(c)
				end
			end
		else
			Victim:BreakJoints()
			local FIRES = {}
			for _, e in pairs(Victim:GetDescendants()) do
				if e:IsA("BasePart") and e.Name ~= "HumanoidRootPart" and e.Parent.ClassName ~= "Folder" then
					e.Transparency = 1
					e:ClearAllChildren()
					local FIRE = script.HellFire:Clone()
					FIRE.Parent = e
					FIRE.Enabled = true
					table.insert(FIRES,FIRE)
				elseif e.ClassName == "Decal" then
					e:remove()
				end	
			end
			for i = 1, 50 do
				Victim:BreakJoints()
				wait()
			end
			for i = 1, #FIRES do
				FIRES[i].Enabled = false
			end
			wait(1.1)
			Victim:remove()
		end
	end))
end

function ApplyDeathAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL,OPTION)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
							if OPTION ~= nil then
								Kill(CHILD,OPTION)
							end
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING ~= 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function FingerMagic()
	ATTACK = true
	Rooted = false
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(5-3 * COS(SINE / 6)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * ANGLES(RAD(0), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.15 + 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(160), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(3,3,3), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 304999618, SoundPitch = 1, SoundVolume = 1})
	for i = 1, 5 do
		WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,7,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 2, SoundVolume = 1})
	end
	CreateSound(217767125, LeftArm, 10, 1, false)
	coroutine.resume(coroutine.create(function()
		local EXPLODED = false
		for i = 1, 3 do
			coroutine.resume(coroutine.create(function()
				local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 15, Character)
				if HITFLOOR then
					local CFRAME = CF(HITPOS) * ANGLES(RAD(0), RAD((360/3)*i), RAD(0))
					for i = 1, 35 do
						wait()
						for _, c in pairs(workspace:GetChildren()) do
							if EXPLODED == false and c.ClassName == "Model" and c:FindFirstChildOfClass("Humanoid") and c ~= Character then
								local HUM = c:FindFirstChildOfClass("Humanoid")
								local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
								if TORSO and HUM.Health > 0 then
									if (TORSO.Position - CFRAME.p).Magnitude < 10 then
										EXPLODED = true
										coroutine.resume(coroutine.create(function()
											for i = 1, 15 do
												ApplyDeathAoE(CFRAME*CF(0,10,0).p,30+(i*4),0,0,-35,false)
												wait(0.2)
												WACKYEFFECT({Time = 35, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(15+(i*2),5,15+(i*2)), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-2,2)*15, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = 1, SoundVolume = 7})
												WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(15,15,15)+VT(i*2,i*2,i*2), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = CFRAME*CF(0,10,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 304999618, SoundPitch = 1, SoundVolume = 1})
												WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(12,12,12)+VT(i*2,i*2,i*2), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = CFRAME*CF(0,10,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0.7,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 1})
											end
											WACKYEFFECT({Time = 50, EffectType = "Block", Size = VT(15,15,15)+VT(i*2,i*2,i*2), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0, CFrame = CFRAME*CF(0,10,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 304999618, SoundPitch = 1, SoundVolume = 1})
											wait(1)
											WACKYEFFECT({Time = 60, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(100,100,100)*5, Transparency = 0.4, Transparency2 = 1, CFrame = CFRAME*CF(0,10,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0.3,0,0), SoundID = 461105534, SoundPitch = 1, SoundVolume = 10})
											local PART = CreatePart(3, Effects, "Neon", 0, 1, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
											PART.CFrame = CFRAME*CF(0,10,0)
											Debris:AddItem(PART,10)
											local PARTICLES = script.Explode:Clone()
											PARTICLES.Parent = PART
											PARTICLES:Emit(500)
											ApplyDeathAoE(CFRAME*CF(0,10,0).p,45*2,0,0,350,true)
											WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(90,90,90)*2, Transparency = 0.8, Transparency2 = 1, CFrame = CFRAME*CF(0,10,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 3})
											WACKYEFFECT({EffectType = "Ring", Size = VT(00,0.01)/20, Size2 = VT(35,35,0.01), Transparency = 0.7, Transparency2 = 1, CFrame = CFRAME*CF(0,10,0)*ANGLES(RAD(0), RAD(90), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
											WACKYEFFECT({EffectType = "Ring", Size = VT(00,0.01)/20, Size2 = VT(35,35,0.01), Transparency = 0.7, Transparency2 = 1, CFrame = CFRAME*CF(0,10,0)*ANGLES(RAD(90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
										end))
									end
								end
							end
						end
						if EXPLODED == true then
							break
						end
						CFRAME = CFRAME * ANGLES(RAD(0), RAD(10), RAD(0)) * CF(0,0,-3)
						WACKYEFFECT({Time = 35, EffectType = "Wave", Size = VT(10,15,10), Size2 = VT(0,35,0), Transparency = 1, Transparency2 = 0.9, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-2,2)*15, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = 1, SoundVolume = 7})
						WACKYEFFECT({Time = 35, EffectType = "Wave", Size = VT(15,15,15), Size2 = VT(0,25,0), Transparency = 1, Transparency2 = 0.6, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-2,2)*15, RotationZ = 0, Material = "Neon", Color = BRICKC"Maroon".Color, SoundID = nil, SoundPitch = 1, SoundVolume = 7})
					end
				end
			end))
		end
	end))
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * ANGLES(RAD(0), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.15 + 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(170), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function EMOTE()
	ATTACK = true
	Rooted = false
	local LOOP = 0
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(5-3 * COS(SINE / 6)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	for i=0, 3, 0.1 / Animation_Speed do
		Swait()
		LOOP = LOOP + 1
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.8, 0.4) * ANGLES(RAD(170), RAD(0), RAD(-25 - 25 * SIN(LOOP / 5))) * ANGLES(RAD(0), RAD(-45), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.4) * ANGLES(RAD(5-3 * COS(SINE / 6)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function Roar()
	ATTACK = true
	Rooted = true
	local ROAR = CreateSound("199978176", Head, 10, 1)
	Swait()
	repeat
		Swait()
		ROAR.Parent = Head
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-15 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	until ROAR.Playing == false
	ATTACK = false
	Rooted = false
end

function Minutes()
	ATTACK = true
	Rooted = false
	CreateSound(159882644, Character, 10, 1, false)
	for i=0, 3.5, 0.1 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(2 + math.cos(SINE / 70) * math.cos(SINE / 20) - 2, 0 , 5 + 1.5* Player_Size * math.cos(SINE / 20)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function TenebrisTAUNT1()
	ATTACK = true
	Rooted = false
	CreateSound(865772398, Torso, 6, 1, false)
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function Roar2()
	ATTACK = true
	Rooted = true
	local ROAR = CreateSound("528589078", Head, 10, 1)
	Swait()
	repeat
		Swait()
		ROAR.Parent = Head
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-15 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-15 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	until ROAR.Playing == false
	ATTACK = false
	Rooted = false
end

--//=================================\\
--||      ASSIGN THINGS TO KEYS
--\\=================================//
 
function MouseDown(Mouse)
    if ATTACK == false then
    end
end
 
function MouseUp(Mouse)
HOLD = false
end

local FLIGHT = false

function KeyDown(Key)
    KEYHOLD = true
	if Key == "z" and ATTACK == false then
		if MODE == "Main" then
		Lunar_Blast()
		elseif MODE == "Phaedra" then
		Dolor_Pluvia()
		elseif MODE == "Tenebris" then
		Dark_Blast()
		elseif MODE == "Fugatrix" then
		Banisher_Bullet()
		elseif MODE == "Praefectus" then
		Governor_Bomb()
		elseif MODE == "Demonum" then
		Governor_Bomb2()
		elseif MODE == "Mortem" then
		Dead_Bullet()
		elseif MODE == "Ultra Phaedra" then
		Ultimate_Z()
	end
end

	if Key == "t" and ATTACK == false then
		if MODE == "Main" then
		CreateSound("907330011", Head, 10, 1.2)
		elseif MODE == "Phaedra" then
		Roar()
		elseif MODE == "Tenebris" then
		TenebrisTAUNT1()
		elseif MODE == "Maris" then
		Minutes()
		elseif MODE == "Fugatrix" then
		CreateSound(221057812,Torso,10,1,false)
		elseif MODE == "Praefectus" then
		ATTACK = true
		CreateSound(363808674, Torso, 6, 1, false)
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		for i=0, 0.6, 0.1 / Animation_Speed do
			Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)

			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(35), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -0.5) * ANGLES(RAD(100), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		ATTACK = false
		elseif MODE == "Demonum" then
		Roar2()
		elseif MODE == "Mortem" then
		EMOTE()
		elseif MODE == "Ultra Phaedra" then
		Roar()
	end
end

if Key == "space" then 
Humanoid.Jump = true
end

	if Key == "zero" and ATTACK == false then
		PhForm()
	end

	if Key == "semicolon" and ATTACK == false then
		FinalForm()
	end

	if Key == "m" and ATTACK == false and MODE == "Phaedra" then
		UpForm()
	end

	if Key == "zero" and ATTACK == false and MODE == "Ultra Phaedra" then
		UpForm()
	end

	if Key == "m" and ATTACK == false and MODE == "Praefectus" then
		DeForm()
	end

	if Key == "three" and ATTACK == false and MODE == "Demonum" then
		DeForm()
	end

	if Key == "three" and ATTACK == false then
		PrForm()
	end

	if Key == "m" and ATTACK == false and MODE == "Tenebris" then
		VeForm()
	end

	if Key == "one" and ATTACK == false and MODE == "Venari" then
		VeForm()
	end

	if Key == "four" and ATTACK == false then
		InForm()
	end

	if Key == "x" and ATTACK == false and MODE == "Phaedra" then
		LEVEL = 3
		Ultima_Consummatio()
		LEVEL = 1
	end

	if Key == "m" and ATTACK == false and MODE == "Fugatrix" then
		DeathForm()
	end

	if Key == "two" and ATTACK == false and MODE == "Mortem" then
		DeathForm()
	end

	if Key == "two" and ATTACK == false then
		BaForm()
	end

	if Key == "one" and ATTACK == false then
		TeForm()
	end

	if Key == "b" and ATTACK == false then
		if MODE == "Main" then
        	Star_Cutter()
		elseif MODE == "Phaedra" then 
			Ignem_Aeternum()
		elseif MODE == "Tenebris" then
			Dark_Cutter()
		elseif MODE == "Fugatrix" then
		    Ruler2()
		elseif MODE == "Praefectus" then
			Command_Rush()
		elseif MODE == "Demonum" then
			Blizzard()
		elseif MODE == "Ultra Phaedra" then
			Ultimate_B()
		elseif MODE == "Mortem" then
			Dead_Cutter()
		end
	end

	if Key == "c" and ATTACK == false then
		if MODE == "Main" then
		Supernova()
		elseif MODE == "Phaedra" then
		Ultima_Consummatio()
		elseif MODE == "Tenebris" then
		SupernovaThrow()
		elseif MODE == "Fugatrix" then
		Ultima_ConsummatioB()
		elseif MODE == "Praefectus" then
		Ruler()
		elseif MODE == "Demonum" then
		SupernovaThrow()
		elseif MODE == "Ultra Phaedra" then
		Governor_Bomb3()
		elseif MODE == "Mortem" then
		FingerMagic()
		end
	end

	if Key == "q" and ATTACK == false then
		if MODE == "Main" then
		Astral_Hop()
		elseif MODE == "Phaedra" then
		Hop()
		elseif MODE == "Tenebris" then
		Astral_Hop()
		elseif MODE == "Venari" then
		SummonHop()
		elseif MODE == "Fugatrix" then
		Banish_Hop()
		elseif MODE == "Praefectus" then
		Monarch_Hop()
		elseif MODE == "Demonum" then
		Banish_Hop()
		elseif MODE == "Mortem" then
		Banish_Hop()
		elseif MODE == "Ultra Phaedra" then
		Hop()
		end
	end
end
 
function KeyUp(Key)
    KEYHOLD = false
end
 
    Mouse.Button1Down:connect(function(NEWKEY)
        MouseDown(NEWKEY)
    end)
    Mouse.Button1Up:connect(function(NEWKEY)
        MouseUp(NEWKEY)
    end)
    Mouse.KeyDown:connect(function(NEWKEY)
        KeyDown(NEWKEY)
    end)
    Mouse.KeyUp:connect(function(NEWKEY)
        KeyUp(NEWKEY)
    end)
 
--//=================================\\
--\\=================================//
 
 
function unanchor()
    if UNANCHOR == true then
        g = Character:GetChildren()
        for i = 1, #g do
            if g[i].ClassName == "Part" then
                g[i].Anchored = false
            end
        end
	g = Weapon:GetChildren()
	for i = 1, #g do
		if g[i].ClassName == "Part" then
			g[i].Anchored = false
		end
	end
    end
end
 
 
--//=================================\\
--||    WRAP THE WHOLE SCRIPT UP
--\\=================================//

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", Character)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
Swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end))
end

Humanoid.Changed:connect(function(Jump)
    if Jump == "Jump" and (Disable_Jump == true) then
        Humanoid.Jump = false
    end
end)
 
Humanoid.HipHeight = 2
Head:ClearAllChildren()

Speed = 35
local EXTRATRANS = 0


 
local FOUNDFORGOTTEN = false

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

local m = Instance.new("Model",Character)

local cen = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(cen,RootPart,cen,0,3,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local effar = Instance.new("ParticleEmitter",cen)
effar.Texture = "rbxassetid://2344870656"
effar.LightEmission = 1
effar.Color = ColorSequence.new(Color3.new(1,0,0))
effar.Rate = 50
effar.Enabled = false
effar.EmissionDirection = "Front"
effar.Lifetime = NumberRange.new(1)
effar.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,40,0)})
effar.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
effar.Speed = NumberRange.new(80,90)
effar.Acceleration = Vector3.new(0,10,0)
effar.Drag = 5
effar.Rotation = NumberRange.new(-500,500)
effar.SpreadAngle = Vector2.new(0,900)
effar.RotSpeed = NumberRange.new(-500,500)

while true do
    Swait()
    ANIMATE.Parent = nil
    Humanoid.HipHeight = 2
    SINE = SINE + CHANGE
    local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
    local TORSOVERTICALVELOCITY = RootPart.Velocity.y
    local LV = Torso.CFrame:pointToObjectSpace(Torso.Velocity - Torso.Position)
    local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
    if ATTACK == false then
        if TORSOVELOCITY < 1 and MODE == "Main" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Main" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and MODE == "Demonum" then
		SKILLTEXTCOLOR = C3(1, 0, 0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		local snap = math.random(1,2)
		if snap == 1 then
			SKILLTEXTCOLOR = C3(0,0,0)
			SKILLTEXTCOLOR2 = C3(1,0,0)
		end
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.5 * SIN(SINE / 12), 0 + 0.25 * COS(SINE / 32), 1 + 1 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 24))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9*SIZE, 0.5*SIZE + 0.05*SIZE * SIN(SINE / 12), -0.5) * ANGLES(RAD(100), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.9*SIZE, 0.25*SIZE + 0.05*SIZE * SIN(SINE / 12), -0.35) * ANGLES(RAD(70), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Demonum" then
		SKILLTEXTCOLOR = C3(1, 0, 0)
		SKILLTEXTCOLOR2 = C3(0,0,0)
		local snap = math.random(1,2)
		if snap == 1 then
			SKILLTEXTCOLOR = C3(0,0,0)
			SKILLTEXTCOLOR2 = C3(1,0,0)
		end
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.5 * SIN(SINE / 12), 0 + 0.25 * COS(SINE / 32), 1 + 1 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 24))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9*SIZE, 0.5*SIZE + 0.05*SIZE * SIN(SINE / 12), -0.5) * ANGLES(RAD(100), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.9*SIZE, 0.25*SIZE + 0.05*SIZE * SIN(SINE / 12), -0.35) * ANGLES(RAD(70), RAD(0), RAD(80)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and MODE == "Phaedra" then
		SKILLTEXTCOLOR = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
		SKILLTEXTCOLOR2 = C3(1,1,1)
		local snap = math.random(1,2)
		if snap == 1 then
			SKILLTEXTCOLOR = C3(1,1,1)
			SKILLTEXTCOLOR2 = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
		end
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 - 1 * SIN(SINE / 22), 0, 2 + 1.5 * COS(SINE / 22)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 24)), RAD(9*SIN(SINE/24)), RAD(6*SIN(SINE/24))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.1 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.1 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Phaedra" then
		SKILLTEXTCOLOR = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
		SKILLTEXTCOLOR2 = C3(1,1,1)
		local snap = math.random(1,2)
		if snap == 1 then
			SKILLTEXTCOLOR2 = C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116)
			SKILLTEXTCOLOR = C3(1,1,1)
		end
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 - 1 * SIN(SINE / 22), 0, 2 + 1.5 * COS(SINE / 22)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(15 * SIN(SINE / 28)), RAD(5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and MODE == "Tenebris" then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Tenebris" then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.35, -0.35) * ANGLES(RAD(70), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and MODE == "Fugatrix" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Fugatrix" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-45), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(32 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and MODE == "Praefectus" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			if MRANDOM(1,7) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
			end
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(25 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Praefectus" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			if MRANDOM(1,7) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
			end
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and MODE == "Venari" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 1 * SIN(SINE / 22), 0, 1 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Venari" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 1 * SIN(SINE / 22), 0, 1 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and MODE == "Ultra Phaedra" then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 - 1 * SIN(SINE / 22), 0, 2 + 1.5 * COS(SINE / 22)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 24)), RAD(9*SIN(SINE/24)), RAD(6*SIN(SINE/24))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.1 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.1 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
        elseif TORSOVELOCITY > 1 and MODE == "Ultra Phaedra" then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 - 1 * SIN(SINE / 22), 0, 2 + 1.5 * COS(SINE / 22)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(15 * SIN(SINE / 28)), RAD(5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif TORSOVELOCITY < 1 and MODE == "Mortem" then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0.4) * ANGLES(RAD(-5), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif TORSOVELOCITY > 1 and MODE == "Mortem" then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.6) * ANGLES(RAD(165), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif TORSOVELOCITY < 1 and MODE == "Maris" then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(2 + math.cos(SINE / 70) * math.cos(SINE / 20) - 2, 0 , 5 + 1.5* Player_Size * math.cos(SINE / 20)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif TORSOVELOCITY > 1 and MODE == "Maris" then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(2 + math.cos(SINE / 70) * math.cos(SINE / 20) - 2, 0 , 5 + 1.5* Player_Size * math.cos(SINE / 20)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif TORSOVELOCITY < 1 and MODE == "Insaniam" then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			if MRANDOM(1,2) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
			end
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			elseif TORSOVELOCITY > 1 and MODE == "Insaniam" then
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(25 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			if MRANDOM(1,2) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
			end
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(15 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-25), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
      end
	end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", Character)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = VT(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
Swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
Swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

if MODE == "Maris"  then
if HITFLOOR ~= nil then
    sphereMK(2,-0.5,"Add",RootPart.CFrame*CFrame.new(math.random(-25,25),math.random(10,15),math.random(-25,25))*CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),0.25,0.25,5,0.0075,BrickColor.new("Storm blue"),0)
   WACKYEFFECT({EffectType = "Round Slash", Size = VT(0,0.05,0), Size2 = VT(0.25,0.08,0.25), Transparency = 0.2, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2.85,0) * ANGLES(RAD(0), RAD(MRANDOM(-180,180)), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = MRANDOM(0,0.5), Material = "Neon", Color = C3(255/255,255/255,255/255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
end
end
	if MODE == "Ultra Phaedra" then
	if HITFLOOR ~= nil then
	Slice("Round", 0.75, 35, CF(HITPOS + VT(0, 0.1, 0), HITPOS + VT(0, 0.1, 0) + NORMAL) * ANGLES(RAD(90), RAD(0), RAD(0)) * ANGLES(RAD(MRANDOM(-18, 18)), RAD(MRANDOM(-180, 180)), RAD(MRANDOM(-18, 18))), "White", VT(0.001, 0, 0.001))
	Slice("Round", 0.75, 45, CF(HITPOS + VT(0, 0.1, 0), HITPOS + VT(0, 0.1, 0) + NORMAL) * ANGLES(RAD(90), RAD(MRANDOM(-180, 180)), RAD(0)), "Light yellow", VT(0, 0, 0))
	ApplyAoE(RootPart.Position, 10, 2, 5, 0, true)
	end
	MagicSphere(VT(1,1,1)/5,35,CF(RootPart.Position)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))*CF(0,MRANDOM(3,6),0),C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116),VT(0,0,0))
        Slice("Round", 0.25, 5, CF(RootPart.Position)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))*CF(0,MRANDOM(3,6),0), C3(0.7372549019607844, 0.6078431372549019, 0.36470588235294116), VT(-0.01, 0, -0.01))
    end
    unanchor()
    Humanoid.MaxHealth = "inf"
    Humanoid.Health = "inf"
    if Rooted == false then
        Disable_Jump = false
        Humanoid.WalkSpeed = Speed
    elseif Rooted == true then
        Disable_Jump = true
        Humanoid.WalkSpeed = 0
    end
if MODE == "Main" then
tecks2.Text = "Dominus Astra"
SKILLTEXTCOLOR = C3(0.05,0.05,0.15)
SKILLTEXTCOLOR2 = C3(0,0,0)
end
    if MODE == "Phaedra" or MODE == "Ultra Phaedra" then
end
    sick.Parent = Character
	tecks2.TextColor3 = SKILLTEXTCOLOR
	tecks2.TextStrokeColor3 = SKILLTEXTCOLOR2
    script.Parent = WEAPONGUI
    Character.Parent = workspace
     for _, c in pairs(game.Players:GetChildren()) do
        if c.Character ~= nil then
            if c.Character.Parent ~= workspace and c.Character.Parent ~= nil then
                c.Character:BreakJoints()
            end
        end
    end
    FOUNDFORGOTTEN = false
    Humanoid.DisplayDistanceType = "None"
    for _, c in pairs(workspace:GetChildren()) do
        if c.ClassName == "Model" then
            for _, q in pairs(c:GetChildren()) do
                if q.Name == ("Forgotten Dominus") then
                    FOUNDFORGOTTEN = true
                end
            end
        end
    end
    if FOUNDFORGOTTEN == true then
        sick:Stop()
    else
        sick.Playing = true
    end
if INTRO == false and INSTANT == false then
        INTRO = true
        coroutine.resume(coroutine.create(function()
            sick:Play()
            sick:Resume()
            Intro()
        end))
    end
    if INSTANT == true then
        if TRANSFORMED == false then
            sick.TimePosition = 20.7
            sick:Play()
            sick:Resume()
        end
        TRANSFORMED = true
    end
if MODE == "Insaniam" then
for i, v in pairs(Character:GetChildren()) do
if v:IsA("Part") then
v.BrickColor = BrickColor.random()
end
end
	BodyColor = BrickColor.random().Color
	LegColor = BrickColor.random().Color
	ArmColor = BrickColor.random().Color
	SKILLTEXTCOLOR = BrickColor.random().Color
	SKILLTEXTCOLOR2 = BrickColor.random().Color
end
for _, c in pairs(Character:GetDescendants()) do
		if c.ClassName == "Part" and c.Name == "Eye" then
			c.Color = C3(1,0,0)
			c.Material = "Neon"
		end
end

    if VALUE1 == false and MODE == "Main" then
        MagicSphere(VT(1,1,1)/5,35,CF(Torso.Position)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))*CF(0,MRANDOM(3,6),0),C3(1,1,1),VT(0,0,0))
    end
end
 

--//=================================\\
--\\=================================//
 
 
 
 
 
--//====================================================\\--
--||                     END OF SCRIPT
--\\====================================================//--



-------------------------------------------------



